<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://mengfanfan.github.io</id>
    <title>孟饭饭的独立博客</title>
    <updated>2021-06-08T14:41:24.690Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mengfanfan.github.io"/>
    <link rel="self" href="https://mengfanfan.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://mengfanfan.github.io/images/avatar.png</logo>
    <icon>https://mengfanfan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 孟饭饭的独立博客</rights>
    <entry>
        <title type="html"><![CDATA[Git Commit Message 提交规范配置说明]]></title>
        <id>https://mengfanfan.github.io/post/git-commit-message-ti-jiao-gui-fan-pei-zhi-shuo-ming/</id>
        <link href="https://mengfanfan.github.io/post/git-commit-message-ti-jiao-gui-fan-pei-zhi-shuo-ming/">
        </link>
        <updated>2020-05-23T06:31:55.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="描述">描述</h2>
<p>针对 git commit log 提交规范的问题，需要统一规范，不然很容易造成误解。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="描述">描述</h2>
<p>针对 git commit log 提交规范的问题，需要统一规范，不然很容易造成误解。</p>
<!-- more -->
<h2 id="commitizen-替代你的-git-commit">Commitizen: 替代你的 git commit</h2>
<h3 id="全局安装">全局安装</h3>
<pre><code>npm install -g commitizen
</code></pre>
<h3 id="项目级安装">项目级安装</h3>
<pre><code>npm install -D commitizen cz-customizable --dev
</code></pre>
<p><code>package.json</code>中配置:</p>
<pre><code>  &quot;config&quot;: {
    &quot;commitizen&quot;: {
      &quot;path&quot;: &quot;node_modules/cz-customizable&quot;
    }
  },
</code></pre>
<h3 id="配置规则">配置规则</h3>
<p>.cz-config.js 中写入自定义的配置：</p>
<pre><code>'use strict'

module.exports = {
  types: [
    {
      value: '💪 WIP',
      name: '进度: 工作进度',
    },
    {
      value: '✨ feat',
      name: '功能: 新功能',
    },
    {
      value: '🐞 fix',
      name: '修复: 修复bug',
    },
    {
      value: '🛠 refactor',
      name: '重构: 代码重构',
    },
    {
      value: '📚  docs',
      name: '文档: 只有文档变更',
    },
    {
      value: '🏁  test',
      name: '测试: 添加一个测试',
    },
    {
      value: '🗯 chore',
      name: '工具: 没有修改源代码，只是变更构建流程或辅助工具。',
    },
    {
      value: '💅 style',
      name: '样式: 空格，分号等格式修复。',
    },
    {
      value: '⏪ revert',
      name: '回滚: 代码回退。',
    },
    {
      value: '🏎  perf',
      name: '性能: 提升性能。',
    },
    {
      value: '🏗 build',
      name: '构建: 变更项目构建或外部依赖（例如scopes: webpack、gulp、npm等）',
    },
    {
      value: '🕹 ci',
      name:
        '集成: 更改持续集成软件的配置文件和package中的scripts命令，例如scopes: Travis, Circle等',
    },
  ],
  scopes: [],
  messages: {
    type: '选择一种你的提交类型:',
    scope: '选择一个scope (可选):',
    // used if allowCustomScopes is true
    customScope: 'Denote the SCOPE of this change:',
    subject: '短说明:\n',
    body: '长说明，使用&quot;|&quot;换行(可选)：\n',
    breaking: '非兼容性说明 (可选):\n',
    footer: '关联关闭的issue，例如：#31, #34(可选):\n',
    confirmCommit: '确定提交说明？',
  },
  footerPrefix: 'TAPD: ',
  allowCustomScopes: true,
  allowBreakingChanges: ['特性', '修复'],
  skipQuestions: ['scope', 'body', 'footer'],
}
</code></pre>
<p>效果如下：</p>
<figure data-type="image" tabindex="1"><img src="https://mengfanfan.github.io/post-images/1590216132807.png" alt="" loading="lazy"></figure>
<h3 id="commitlint-校验你的-message">Commitlint: 校验你的 message</h3>
<p>commitlint: 可以帮助我们 lint commit messages, 如果我们提交的不符合指向的规范, 直接拒绝提交。</p>
<pre><code>yarn add commitlint-config-cz @commitlint/cli --dev
</code></pre>
<p>.commitlintrc.js 中写入:</p>
<pre><code>module.exports = {
  extends: [
    'cz'
  ],
  rules: {
  }
};
</code></pre>
<h3 id="结合-husky">结合 Husky</h3>
<p>校验 commit message 的最佳方式是结合 git hook, 所以需要配合 Husky。</p>
<pre><code>npm i husky@next
</code></pre>
<p>package.json 中添加:</p>
<pre><code>&quot;husky&quot;: {
    &quot;hooks&quot;: {
      ...,
      &quot;commit-msg&quot;: &quot;commitlint -e $GIT_PARAMS&quot;
    }
  },
</code></pre>
<p><a href="https://juejin.im/post/5afc5242f265da0b7f44bee4">参考</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[满足大屏场景的拖拽组件原理说明]]></title>
        <id>https://mengfanfan.github.io/post/man-zu-da-ping-chang-jing-de-tuo-zhuai-zu-jian-yuan-li-shuo-ming/</id>
        <link href="https://mengfanfan.github.io/post/man-zu-da-ping-chang-jing-de-tuo-zhuai-zu-jian-yuan-li-shuo-ming/">
        </link>
        <updated>2020-05-22T01:50:31.000Z</updated>
        <summary type="html"><![CDATA[<p>✍️ 源于大屏场景下，由于进行适配页面尺寸，随着页面尺寸的频繁变化，导致拖拽组件的定位失效，引起拖拽异常......</p>
]]></summary>
        <content type="html"><![CDATA[<p>✍️ 源于大屏场景下，由于进行适配页面尺寸，随着页面尺寸的频繁变化，导致拖拽组件的定位失效，引起拖拽异常......</p>
<!-- more -->
<h3 id="场景">场景🦄</h3>
<p><strong>组件需要满足功能：</strong></p>
<ul>
<li>基本PC端拖拽功能；</li>
<li>适配屏幕尺寸变化；</li>
<li>支持传入组件的定位<code>top, left</code>；（防止突发性页面尺寸比例变化，拖拽组件定位失效）</li>
</ul>
<h3 id="拖拽原理">拖拽原理</h3>
<h4 id="所需事件">所需事件</h4>
<ul>
<li>onMousedown</li>
<li>onMouseup</li>
<li>onMousemove</li>
</ul>
<h4 id="原理说明">原理说明</h4>
<h5 id="原理图">原理图🍥</h5>
<figure data-type="image" tabindex="1"><img src="https://mengfanfan.github.io/post-images/1590112364894.png" alt="" loading="lazy"></figure>
<h5 id="状态参数">状态参数</h5>
<pre><code>const dragData = 
{
    // x偏移值
    offsetX: 0,
    // y偏移值
    offsetY: 0,
    // 是否开始拖拽
    isDrag: false,
    // 当前组件距离当前窗口x轴的距离
    distanceX: 0,
    // 当前组件距离当前窗口y轴的距离
    distanceY: 0,
    // 组件top定位
    top: 0,
    // 组件left定位
    left: 0,
}
</code></pre>
<h5 id="步骤">步骤</h5>
<blockquote>
<p>第一步</p>
</blockquote>
<p>鼠标移动到组件可触发区域，鼠标按下，触发<code>onMousedown</code>事件，记录鼠标点击位置，开启拖动</p>
<pre><code>// 记录鼠标点击位置
dragData.distanceX = e.clientX
dragData.distanceY = e.clientY
// 开启拖动
 dragData.isDrag = true
</code></pre>
<blockquote>
<p>第二步</p>
</blockquote>
<p>鼠标移动，触发<code>onMousemove</code>事件，判断<code>dragData.isDrag</code>是否为真，为假跳出执行，为真继续执行。通过计算移动的距离，获取当前组件位置，算出最新位置，对组件进行更新位置信息。并记录当前组件距离当前窗口的距离、此时的偏移位置；</p>
<p><strong>计算移动的距离：</strong></p>
<p>计算移动的距离 = 本次距离当前窗口移动距离 - 上次距离当前窗口移动距离 + 上一次移动距离</p>
<pre><code>const moveDistanceX = e.clientX - distanceX + offsetX
const moveDistanceY = e.clientY - distanceY + offsetY
</code></pre>
<p><strong>获取最新位置：</strong></p>
<p>不带页面缩放：</p>
<p>最新位置 = 当前组件的位置 + 移动的距离</p>
<p>带页面缩放：</p>
<p>最新位置 = 当前组件的位置 + 移动的距离/页面缩放系数</p>
<pre><code>const _left = left + moveDistanceX / scaleX
const _top = top + moveDistanceY / scaleY
</code></pre>
<p><strong>更新组件位置信息：</strong></p>
<pre><code>el.style.left = _left + 'px'
el.style.top = _top + 'px'
</code></pre>
<p><strong>记录状态：</strong></p>
<p>记录当前组件距离当前窗口的距离：</p>
<pre><code>dragData.distanceX = e.clientX
dragData.distanceY = e.clientY
</code></pre>
<p>记录当前偏移位置</p>
<pre><code>dragData.offsetX = moveDistanceX
dragData.offsetY = moveDistanceY
</code></pre>
<blockquote>
<p>第三步</p>
</blockquote>
<p>鼠标抬起，触发<code>onMouseup</code>事件，关闭拖动；</p>
<pre><code>dragData.isDrag = false
</code></pre>
<h3 id="适配屏幕尺寸变化">适配屏幕尺寸变化</h3>
<h4 id="场景-2">场景</h4>
<p>用户控制屏幕，使屏幕尺寸发送变化，使拖拽组件保存的定位信息过期，导致拖拽异常。</p>
<h4 id="所需事件-2">所需事件</h4>
<ul>
<li>onResize</li>
</ul>
<h4 id="原理说明-2">原理说明</h4>
<p>向<code>window</code>绑定<code>resize</code>事件，监控页面尺寸变化，当尺寸发生变化，或者最新组件定位，清空保存的定位状态信息。</p>
<pre><code>const { left, top } = el.style
const _top = +top.replace(/px/, '')
const _left = +left.replace(/px/, '')
dragData = {
   offsetX: 0,
   offsetY: 0,
   isDrag: false,
   distanceX: 0,
   distanceY: 0,
   top: _top,
   left: _left,
}
</code></pre>
<h3 id="突发性页面尺寸比例变化定位修复">突发性页面尺寸比例变化定位修复</h3>
<h4 id="场景-3">场景</h4>
<p>没有通过<code>resize</code>事件触发的页面尺寸变化，通过修改页面宽高等导致页面尺寸变化，这时组件定位不准，需要恢复同比例下组件定位，并保证组件拖拽无异常。</p>
<h4 id="条件">条件</h4>
<p>页面原始宽高，变化后页面宽高</p>
<h4 id="方案">方案</h4>
<p>根据页面比例，计算出最新组件位置，对组件进行更新位置信息，并清空保存的定位状态信息。</p>
<p>页面比例 = 页面原始宽高 / 变化后页面宽高</p>
<p>最新组件位置 = 当前组件位置 / 页面比例</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【转】7分钟理解JS的节流、防抖及使用场景]]></title>
        <id>https://mengfanfan.github.io/post/zhuan-7-fen-zhong-li-jie-js-de-jie-liu-fang-dou-ji-shi-yong-chang-jing/</id>
        <link href="https://mengfanfan.github.io/post/zhuan-7-fen-zhong-li-jie-js-de-jie-liu-fang-dou-ji-shi-yong-chang-jing/">
        </link>
        <updated>2019-06-03T08:25:49.000Z</updated>
        <summary type="html"><![CDATA[<p>据说阿里有一道面试题就是谈谈函数节流和函数防抖。 糟了，这可触碰到我的知识盲区了，好像听也没听过这2个东西，痛定思痛，赶紧学习学习。</p>
]]></summary>
        <content type="html"><![CDATA[<p>据说阿里有一道面试题就是谈谈函数节流和函数防抖。 糟了，这可触碰到我的知识盲区了，好像听也没听过这2个东西，痛定思痛，赶紧学习学习。</p>
<!-- more -->
<h2 id="前言">前言</h2>
<p>据说阿里有一道面试题就是谈谈函数节流和函数防抖。 糟了，这可触碰到我的知识盲区了，好像听也没听过这2个东西，痛定思痛，赶紧学习学习。here we go！</p>
<h2 id="概念和例子">概念和例子</h2>
<h4 id="函数防抖debounce">函数防抖(debounce)</h4>
<blockquote>
<p>在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</p>
</blockquote>
<p>看一个（栗子）：</p>
<pre><code>//模拟一段ajax请求
function ajax(content) {
  console.log('ajax request ' + content)
}

let inputa = document.getElementById('unDebounce')

inputa.addEventListener('keyup', function (e) {
    ajax(e.target.value)
})
</code></pre>
<p>看一下运行结果：</p>
<figure data-type="image" tabindex="1"><img src="https://user-gold-cdn.xitu.io/2018/9/4/165a252be5c94d6b?imageslim" alt="image" loading="lazy"></figure>
<p>可以看到，我们只要按下键盘，就会触发这次ajax请求。不仅从资源上来说是很浪费的行为，而且实际应用中，用户也是输出完整的字符后，才会请求。下面我们优化一下：</p>
<pre><code>//模拟一段ajax请求
function ajax(content) {
  console.log('ajax request ' + content)
}

function debounce(fun, delay) {
    return function (args) {
        let that = this
        let _args = args
        clearTimeout(fun.id)
        fun.id = setTimeout(function () {
            fun.call(that, _args)
        }, delay)
    }
}
    
let inputb = document.getElementById('debounce')

let debounceAjax = debounce(ajax, 500)

inputb.addEventListener('keyup', function (e) {
        debounceAjax(e.target.value)
    })
</code></pre>
<p>看一下运行结果：</p>
<figure data-type="image" tabindex="2"><img src="https://user-gold-cdn.xitu.io/2018/9/4/165a252b4b429b56?imageslim" alt="image" loading="lazy"></figure>
<p>可以看到，我们加入了防抖以后，当你在频繁的输入时，并不会发送请求，只有当你在指定间隔内没有输入时，才会执行函数。如果停止输入但是在指定间隔内又输入，会重新触发计时。 再看一个例子：</p>
<pre><code>let biu = function () {
    console.log('biu biu biu',new Date().Format('HH:mm:ss'))
}

let boom = function () {
    console.log('boom boom boom',new Date().Format('HH:mm:ss'))
}


setInterval(debounce(biu,500),1000)
setInterval(debounce(boom,2000),1000)
</code></pre>
<p>看一下运行结果：</p>
<figure data-type="image" tabindex="3"><img src="https://user-gold-cdn.xitu.io/2018/9/4/165a252b4b809a23?imageslim" alt="image" loading="lazy"></figure>
<p>这个例子就很好的解释了，如果在时间间隔内执行函数，会重新触发计时。biu会在第一次1.5s执行后，每隔1s执行一次，而boom一次也不会执行。因为它的时间间隔是2s，而执行时间是1s，所以每次都会重新触发计时</p>
<blockquote>
<p>个人理解 函数防抖就是法师发技能的时候要读条，技能读条没完再按技能就会重新读条。</p>
</blockquote>
<h4 id="函数节流throttle">函数节流(throttle)</h4>
<blockquote>
<p>规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。</p>
</blockquote>
<p>看一个例子：</p>
<pre><code>function throttle(fun, delay) {
        let last, deferTimer
        return function (args) {
            let that = this
            let _args = arguments
            let now = +new Date()
            if (last &amp;&amp; now &lt; last + delay) {
                clearTimeout(deferTimer)
                deferTimer = setTimeout(function () {
                    last = now
                    fun.apply(that, _args)
                }, delay)
            }else {
                last = now
                fun.apply(that,_args)
            }
        }
    }

    let throttleAjax = throttle(ajax, 1000)

    let inputc = document.getElementById('throttle')
    inputc.addEventListener('keyup', function(e) {
        throttleAjax(e.target.value)
    })
</code></pre>
<p>看一下运行结果：</p>
<figure data-type="image" tabindex="4"><img src="https://user-gold-cdn.xitu.io/2018/9/4/165a252b4c1a9686?imageslim" alt="image" loading="lazy"></figure>
<p>可以看到，我们在不断输入时，ajax会按照我们设定的时间，每1s执行一次。</p>
<p>结合刚刚biubiubiu的例子：</p>
<pre><code>    let biubiu = function () {
        console.log('biu biu biu', new Date().Format('HH:mm:ss'))
    }

    setInterval(throttle(biubiu,1000),10)
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://user-gold-cdn.xitu.io/2018/9/4/165a252b46818296?imageslim" alt="image" loading="lazy"></figure>
<p>不管我们设定的执行时间间隔多小，总是1s内只执行一次。</p>
<blockquote>
<p>个人理解 函数节流就是fps游戏的射速，就算一直按着鼠标射击，也只会在规定射速内射出子弹。</p>
</blockquote>
<h2 id="总结">总结</h2>
<ul>
<li>函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的原理却不一样。</li>
<li>函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。</li>
</ul>
<h4 id="结合应用场景">结合应用场景</h4>
<ol>
<li>
<p>ebounce</p>
<ul>
<li>search搜索联想，用户在不断输入值时，用防抖来节约请求资源。<br>
*window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次</li>
</ul>
</li>
<li>
<p>throttle</p>
<ul>
<li>鼠标不断点击触发，mousedown(单位时间内只触发一次)</li>
<li>监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断</li>
</ul>
</li>
</ol>
<p><em>转载：作者：薄荷前端<br>
<a href="https://juejin.im/post/5b8de829f265da43623c4261">链接</a></em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【转】160行代码仿Vue实现极简双向绑定]]></title>
        <id>https://mengfanfan.github.io/post/zhuan-160-xing-dai-ma-fang-vue-shi-xian-ji-jian-shuang-xiang-bang-ding/</id>
        <link href="https://mengfanfan.github.io/post/zhuan-160-xing-dai-ma-fang-vue-shi-xian-ji-jian-shuang-xiang-bang-ding/">
        </link>
        <updated>2019-05-22T08:26:17.000Z</updated>
        <summary type="html"><![CDATA[<p>精简vue双向绑定机制，对于没有好好研究过这方面知识的同学来说，当然是很难的，接下来本文用160行代码带你实现一个极简的双向绑定机制。</p>
]]></summary>
        <content type="html"><![CDATA[<p>精简vue双向绑定机制，对于没有好好研究过这方面知识的同学来说，当然是很难的，接下来本文用160行代码带你实现一个极简的双向绑定机制。</p>
<!-- more -->
<h2 id="前言">前言</h2>
<p>现在的前端面试不管你用的什么框架，总会问你这个框架的双向绑定机制，有的甚至要求你现场实现一个双向绑定出来，那对于没有好好研究过这方面知识的同学来说，当然是很难的，接下来本文用160行代码带你实现一个极简的双向绑定机制。</p>
<h2 id="效果gif">效果GIF：</h2>
<figure data-type="image" tabindex="1"><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642bc39f2604b1c?imageslim" alt="image" loading="lazy"></figure>
<h2 id="了解objectdefineproperty">了解Object.defineProperty()：</h2>
<p>这个API是实现双向绑定的核心，最主要的作用是重写数据的<code>get</code>、<code>set</code>方法。</p>
<h3 id="使用方式">使用方式：</h3>
<pre><code>    let obj = {
      singer: &quot;周杰伦&quot;
    };
    let value = &quot;青花瓷&quot;;
    Object.defineProperty(obj, &quot;music&quot;, {
      // value: '七里香', // 设置属性的值 下面设置了get set函数 所以这里不能设置
      configurable: false, // 是否可以删除属性 默认不能删除
      // writable: true,  // 是否可以修改对象 下面设置了get set函数 所以这里不能设置
      enumerable: true, // music是否可以被枚举 默认是不能被枚举(遍历)
      // ☆ get,set设置时不能设置writable和value，要一对一对设置，交叉设置/同时存在 就会报错
      get() {
        // 获取obj.music的时候就会调用get方法
        // let value = &quot;强行设置get的返回值&quot;; // 打开注释 读取属性永远都是‘强行设置get的返回值’
        return value;
      },
      set(val) {
        // 将修改的值重新赋给song
        value = val;
      }
    });
    console.log(obj.music); // 青花瓷
    delete obj.music; // configurable设为false 删除无效
    console.log(obj.music); // 青花瓷
    obj.music = &quot;听妈妈的话&quot;; 
    console.log(obj.music); // 听妈妈的话
    for (let key in obj) {
      // 默认情况下通过`defineProperty`定义的属性是不能被枚举(遍历)的
      // 需要设置enumerable为true才可以 否则只能拿到singer 属性
      console.log(key); // singer, music
    }
</code></pre>
<h3 id="画一下重点">画一下重点：</h3>
<ul>
<li>get,set设置时不能设置writable和value, 他们是一对情侣的存在，交叉设置或同时存在,会报错</li>
<li>通过defineProperty设置的属性，默认不能删除，不能遍历，当然你可以通过设置更改他们。</li>
<li>get、set 是函数，可以做的事情很多。</li>
</ul>
<p><strong>兼容性：</strong> IE 9,Firefox 4, Chorme 5,Opera 11.6,Safari 5.1</p>
<h2 id="实现思路">实现思路：</h2>
<h3 id="mvvm系列的双向绑定关键步骤">mvvm系列的双向绑定，关键步骤：</h3>
<ol>
<li>实现数据监听器Observer，用<code>Object.defineProperty()</code><strong>重写数据的get、set，值更新就在set中通知订阅者更新数据</strong>。</li>
<li>实现模板编译Compile，深度遍历dom树，对每个元素节点的指令模板进行<strong>替换数据以及订阅数据</strong>。</li>
<li>实现Watch用于连接Observer和Compile，<strong>能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图</strong>。</li>
<li>mvvm入口函数，整合以上三者。</li>
</ol>
<h3 id="流程图">流程图：</h3>
<figure data-type="image" tabindex="2"><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642bcf24d35456f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image" loading="lazy"></figure>
<h2 id="具体代码实现">具体代码实现：</h2>
<h3 id="html结构">html结构：</h3>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;
    &lt;h3 v-bind=&quot;name&quot;&gt;&lt;/h3&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;testData1&quot;&gt;
    &lt;h3&gt;{{ testData1 }}&lt;/h3&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;testData2&quot;&gt;
    &lt;h3&gt;{{ testData2 }}&lt;/h3&gt;
&lt;/div&gt;
</code></pre>
<h3 id="调用方法">调用方法：</h3>
<p>采用类Vue方式来使用双向绑定：</p>
<pre><code> window.onload = function () {
    var app = new myVue({
        el: '#app', // dom
        data: { // 数据
            testData1: '仿Vue',
            testData2: '极简双向绑定',
            name: 'OBKoro1'
        }
    })
}
</code></pre>
<h3 id="创建myvue函数">创建myVue函数：</h3>
<p>实际上这里是我们实现思路中的第四步，用于整合数据监听器<code>this._observer()</code>、指令解析器<code>this._compile()</code>以及连接Observer和Compile的_watcherTpl的watch池。</p>
<pre><code>    function myVue(options = {}) {  // 防止没传，设一个默认值
        this.$options = options; // 配置挂载
        this.$el = document.querySelector(options.el); // 获取dom
        this._data = options.data; // 数据挂载
        this._watcherTpl = {}; // watcher池
        this._observer(this._data); // 传入数据，执行函数，重写数据的get set
        this._compile(this.$el); // 传入dom，执行函数，编译模板 发布订阅
    };
</code></pre>
<h3 id="watcher函数">Watcher函数:</h3>
<p>这是实现思路中的第三步，因为下方数据监听器_observer()需要用到Watcher函数，所以这里就先讲了。</p>
<p>像实现思路中所说的，这里起到了连接Observer和Compile的作用：</p>
<ol>
<li><strong>在模板编译_compile()阶段发布订阅</strong></li>
<li><strong>在赋值操作的时候，更新视图</strong></li>
</ol>
<pre><code> // new Watcher() 为this._compile()发布订阅+ 在this._observer()中set(赋值)的时候更新视图
 function Watcher(el, vm, val, attr) {
     this.el = el; // 指令对应的DOM元素
     this.vm = vm; // myVue实例
     this.val = val; // 指令对应的值 
     this.attr = attr; // dom获取值，如value获取input的值 / innerHTML获取dom的值
     this.update(); // 更新视图
 }
 Watcher.prototype.update = function () { 
     this.el[this.attr] = this.vm._data[this.val]; // 获取data的最新值 赋值给dom 更新视图
 }
</code></pre>
<p>没有看错，代码量就这么多，可能需要把整个代码连接起来，多看几遍才能够理解。</p>
<h3 id="实现数据监听器_observer">实现数据监听器_observer()：</h3>
<p>实现思路中的第一步，用<code>Object.defineProperty()</code>遍历data重写所有属性的get set。</p>
<p>然后在给对象的某个属性赋值的时候，就会触发set。</p>
<p><strong>在set中我们可以监听到数据的变化，然后就可以触发watch更新视图。</strong></p>
<pre><code> myVue.prototype._observer = function (obj) {
        var _this = this;
        Object.keys(obj).forEach(key =&gt; { // 遍历数据
            _this._watcherTpl[key] = { // 每个数据的订阅池()
                _directives: []
            };
            var value = obj[key]; // 获取属性值
            var watcherTpl = _this._watcherTpl[key]; // 数据的订阅池
            Object.defineProperty(_this._data, key, { // 双向绑定最重要的部分 重写数据的set get
                configurable: true,  // 可以删除
                enumerable: true, // 可以遍历
                get() {
                    console.log(`${key}获取值：${value}`);
                    return value; // 获取值的时候 直接返回
                },
                set(newVal) { // 改变值的时候 触发set
                    console.log(`${key}更新：${newVal}`);
                    if (value !== newVal) {
                        value = newVal;
                        watcherTpl._directives.forEach((item) =&gt; { // 遍历订阅池 
                            item.update();
                            // 遍历所有订阅的地方(v-model+v-bind+{{}}) 触发this._compile()中发布的订阅Watcher 更新视图  
                        });
                    }
                }
            })
        });
    }
</code></pre>
<h3 id="实现compile-模板编译">实现Compile 模板编译</h3>
<p>这里是实现思路中的第三步，让我们来总结一下这里做了哪些事情：</p>
<ul>
<li>
<p>首先是深度遍历dom树，遍历每个节点以及子节点。</p>
</li>
<li>
<p>将模板中的变量替换成数据，初始化渲染页面视图。</p>
</li>
<li>
<p>把指令绑定的属性添加到对应的订阅池中</p>
</li>
<li>
<p>一旦数据有变动，收到通知，更新视图。</p>
</li>
</ul>
<pre><code>  myVue.prototype._compile = function (el) {
      var _this = this, nodes = el.children; // 获取app的dom
      for (var i = 0, len = nodes.length; i &lt; len; i++) { // 遍历dom节点
          var node = nodes[i];
          if (node.children.length) {
              _this._compile(node);  // 递归深度遍历 dom树
          }
          // 如果有v-model属性，并且元素是INPUT或者TEXTAREA，我们监听它的input事件    
          if (node.hasAttribute('v-model') &amp;&amp; (node.tagName = 'INPUT' || node.tagName == 'TEXTAREA')) {
              node.addEventListener('input', (function (key) {
                  var attVal = node.getAttribute('v-model'); // 获取v-model绑定的值
                  _this._watcherTpl[attVal]._directives.push(new Watcher( // 将dom替换成属性的数据并发布订阅 在set的时候更新数据
                      node,
                      _this,
                      attVal,
                      'value'
                  ));
                  return function () {
                      _this._data[attVal] = nodes[key].value;  // input值改变的时候 将新值赋给数据 触发set=&gt;set触发watch 更新视图
                  }
              })(i));
          }
          if (node.hasAttribute('v-bind')) { // v-bind指令 
              var attrVal = node.getAttribute('v-bind'); // 绑定的data
              _this._watcherTpl[attrVal]._directives.push(new Watcher( // 将dom替换成属性的数据并发布订阅 在set的时候更新数据
                  node,
                  _this,
                  attrVal,
                  'innerHTML'
              ))
          }
          var reg = /\{\{\s*([^}]+\S)\s*\}\}/g, txt = node.textContent;   // 正则匹配{{}}
          if (reg.test(txt)) {
              node.textContent = txt.replace(reg, (matched, placeholder) =&gt; {
                  // matched匹配的文本节点包括{{}}, placeholder 是{{}}中间的属性名
                  var getName = _this._watcherTpl; // 所有绑定watch的数据
                  getName = getName[placeholder];  // 获取对应watch 数据的值
                  if (!getName._directives) { // 没有事件池 创建事件池
                      getName._directives = [];
                  }
                  getName._directives.push(new Watcher( // 将dom替换成属性的数据并发布订阅 在set的时候更新数据
                      node,
                      _this,
                      placeholder,
                      'innerHTML'
                  ));
                  return placeholder.split('.').reduce((val, key) =&gt; {
                      return _this._data[key]; // 获取数据的值 触发get 返回当前值 
                  }, _this.$el);
              });
          }
      }
  }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue基于hls.js的流媒体直播基本用法]]></title>
        <id>https://mengfanfan.github.io/post/vue-ji-yu-hlsjs-de-liu-mei-ti-zhi-bo-ji-ben-yong-fa/</id>
        <link href="https://mengfanfan.github.io/post/vue-ji-yu-hlsjs-de-liu-mei-ti-zhi-bo-ji-ben-yong-fa/">
        </link>
        <updated>2019-03-04T08:29:50.000Z</updated>
        <summary type="html"><![CDATA[<p>hls.js是一个实现HTTP Live Streaming客户端的JavaScript库。本篇主要介绍该插件的在vue中基本使用方法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>hls.js是一个实现HTTP Live Streaming客户端的JavaScript库。本篇主要介绍该插件的在vue中基本使用方法。</p>
<!-- more -->
<h2 id="hlsjs-介绍">hls.js 介绍</h2>
<p><a href="https://github.com/video-dev/hls.js">hls.js</a>是一个实现HTTP Live Streaming客户端的JavaScript库。它依靠HTML5视频和MediaSource扩展进行播放。</p>
<p>它的工作原理是将MPEG-2传输流和AAC / MP3流转换为ISO BMFF（MP4）片段。如果在浏览器中可用，则可以使用Web Worker异步执行此传输。<code>hls.js</code>也支持<code>HLS+fmp4</code>，正如在<code>WWDC2016</code>期间宣布的那样<code>hls.js</code>不需要任何播放器，它直接在标准的HTML <code>&lt;video&gt;</code>元素之上工作。<code>hls.js</code> 使用<code>ECMAScript6</code>编写，使用<code>Babel</code>在<code>ECMAScript5</code>中编译。</p>
<h2 id="基本入门">基本入门</h2>
<pre><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/hls.js@latest&quot;&gt;&lt;/script&gt;
&lt;!-- Or if you want a more recent canary version --&gt;
&lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/hls.js@canary&quot;&gt;&lt;/script&gt; --&gt;
&lt;video id=&quot;video&quot;&gt;&lt;/video&gt;
&lt;script&gt;
  var video = document.getElementById('video');
  if(Hls.isSupported()) {
    var hls = new Hls();
    hls.loadSource('https://video-dev.github.io/streams/x36xhzz/x36xhzz.m3u8');
    hls.attachMedia(video);
    hls.on(Hls.Events.MANIFEST_PARSED,function() {
      video.play();
  });
 }
 // hls.js is not supported on platforms that do not have Media Source Extensions (MSE) enabled.
 // When the browser has built-in HLS support (check using `canPlayType`), we can provide an HLS manifest (i.e. .m3u8 URL) directly to the video element throught the `src` property.
 // This is using the built-in support of the plain video element, without using hls.js.
 // Note: it would be more normal to wait on the 'canplay' event below however on Safari (where you are most likely to find built-in HLS support) the video.src URL must be on the user-driven
 // white-list before a 'canplay' event will be emitted; the last video event that can be reliably listened-for when the URL is not on the white-list is 'loadedmetadata'.
  else if (video.canPlayType('application/vnd.apple.mpegurl')) {
    video.src = 'https://video-dev.github.io/streams/x36xhzz/x36xhzz.m3u8';
    video.addEventListener('loadedmetadata',function() {
      video.play();
    });
  }
&lt;/script&gt;
</code></pre>
<h2 id="安装">安装</h2>
<p>要么直接包含dist / hls.js或dist / hls.min.js</p>
<p>或者输入</p>
<pre><code>npm install --save hls.js
</code></pre>
<p>可以选择有一个声明文件可用于帮助完成代码并在hls.js api的IDE中提示</p>
<pre><code>npm install --save-dev @ types / hls.js
</code></pre>
<p>npm方式时，在.vue组件中引入</p>
<pre><code> var Hls = require('hls.js/dist/hls');
</code></pre>
<p><strong>注意：</strong></p>
<p>在vue组件中声明hls实例<code>new Hls()</code>,一定要在组件销毁前注销hls实例，否则会造成内存泄漏（都是坑出来的o(╥﹏╥)o）</p>
<pre><code>beforeDestroy() {
    // 注销hls 实例
    this.hls.destroy();
},
</code></pre>
<h2 id="基本api用法">基本api用法</h2>
<blockquote>
<p>loadSource(url)</p>
</blockquote>
<p>用于加载.m3u8文件路径 {string} url；</p>
<blockquote>
<p>attachMedia()</p>
</blockquote>
<p>挂载media元素；</p>
<blockquote>
<p>destroy()</p>
</blockquote>
<p>注销实例;</p>
<blockquote>
<p>detachMedia()</p>
</blockquote>
<p>Detach from the media;</p>
<blockquote>
<p>startLoad()</p>
</blockquote>
<p>Start loading data from the stream source.Depending on default config, client starts loading automatically when a source is set.</p>
<blockquote>
<p>stopLoad()</p>
</blockquote>
<p>Stop loading of any stream data.</p>
<blockquote>
<p>swapAudioCodec()</p>
</blockquote>
<p>Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)</p>
<blockquote>
<p>recoverMediaError()</p>
</blockquote>
<p>When the media-element fails, this allows to detach and then re-attach it as one call (convenience method).</p>
<h2 id="常规事件">常规事件</h2>
<blockquote>
<p>ERROR</p>
</blockquote>
<p>含义：hls的错误事件。<br>
使用方法：</p>
<pre><code>this.hls = new Hls();
this.hls.on(Hls.Events.ERROR, (data) =&gt; {
    do something~~        
});
</code></pre>
<blockquote>
<p>其它事件介绍</p>
</blockquote>
<pre><code>  // fired before MediaSource is attaching to media element - data: { media }
  MEDIA_ATTACHING: 'hlsMediaAttaching',
  // fired when MediaSource has been succesfully attached to media element - data: { }
  MEDIA_ATTACHED: 'hlsMediaAttached',
  // fired before detaching MediaSource from media element - data: { }
  MEDIA_DETACHING: 'hlsMediaDetaching',
  // fired when MediaSource has been detached from media element - data: { }
  MEDIA_DETACHED: 'hlsMediaDetached',
  // fired when we buffer is going to be reset - data: { }
  BUFFER_RESET: 'hlsBufferReset',
  // fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}
  BUFFER_CODECS: 'hlsBufferCodecs',
  // fired when sourcebuffers have been created - data: { tracks : tracks }
  BUFFER_CREATED: 'hlsBufferCreated',
  // fired when we append a segment to the buffer - data: { segment: segment object }
  BUFFER_APPENDING: 'hlsBufferAppending',
  // fired when we are done with appending a media segment to the buffer - data : { parent : segment parent that triggered BUFFER_APPENDING, pending : nb of segments waiting for appending for this segment parent}
  BUFFER_APPENDED: 'hlsBufferAppended',
  // fired when the stream is finished and we want to notify the media buffer that there will be no more data - data: { }
  BUFFER_EOS: 'hlsBufferEos',
  // fired when the media buffer should be flushed - data { startOffset, endOffset }
  BUFFER_FLUSHING: 'hlsBufferFlushing',
  // fired when the media buffer has been flushed - data: { }
  BUFFER_FLUSHED: 'hlsBufferFlushed',
  // fired to signal that a manifest loading starts - data: { url : manifestURL}
  MANIFEST_LOADING: 'hlsManifestLoading',
  // fired after manifest has been loaded - data: { levels : [available quality levels], audioTracks : [ available audio tracks], url : manifestURL, stats : { trequest, tfirst, tload, mtime}}
  MANIFEST_LOADED: 'hlsManifestLoaded',
  // fired after manifest has been parsed - data: { levels : [available quality levels], firstLevel : index of first quality level appearing in Manifest}
  MANIFEST_PARSED: 'hlsManifestParsed',
  // fired when a level switch is requested - data: { level : id of new level }
  LEVEL_SWITCHING: 'hlsLevelSwitching',
  // fired when a level switch is effective - data: { level : id of new level }
  LEVEL_SWITCHED: 'hlsLevelSwitched',
  // fired when a level playlist loading starts - data: { url : level URL, level : id of level being loaded}
  LEVEL_LOADING: 'hlsLevelLoading',
  // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : { trequest, tfirst, tload, mtime} }
  LEVEL_LOADED: 'hlsLevelLoaded',
  // fired when a level's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, level : id of updated level }
  LEVEL_UPDATED: 'hlsLevelUpdated',
  // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }
  LEVEL_PTS_UPDATED: 'hlsLevelPtsUpdated',
  // fired to notify that audio track lists has been updated - data: { audioTracks : audioTracks }
  AUDIO_TRACKS_UPDATED: 'hlsAudioTracksUpdated',
  // fired when an audio track switching is requested - data: { id : audio track id }
  AUDIO_TRACK_SWITCHING: 'hlsAudioTrackSwitching',
  // fired when an audio track switch actually occurs - data: { id : audio track id }
  AUDIO_TRACK_SWITCHED: 'hlsAudioTrackSwitched',
  // fired when an audio track loading starts - data: { url : audio track URL, id : audio track id }
  AUDIO_TRACK_LOADING: 'hlsAudioTrackLoading',
  // fired when an audio track loading finishes - data: { details : levelDetails object, id : audio track id, stats : { trequest, tfirst, tload, mtime } }
  AUDIO_TRACK_LOADED: 'hlsAudioTrackLoaded',
  // fired to notify that subtitle track lists has been updated - data: { subtitleTracks : subtitleTracks }
  SUBTITLE_TRACKS_UPDATED: 'hlsSubtitleTracksUpdated',
  // fired when an subtitle track switch occurs - data: { id : subtitle track id }
  SUBTITLE_TRACK_SWITCH: 'hlsSubtitleTrackSwitch',
  // fired when a subtitle track loading starts - data: { url : subtitle track URL, id : subtitle track id }
  SUBTITLE_TRACK_LOADING: 'hlsSubtitleTrackLoading',
  // fired when a subtitle track loading finishes - data: { details : levelDetails object, id : subtitle track id, stats : { trequest, tfirst, tload, mtime } }
  SUBTITLE_TRACK_LOADED: 'hlsSubtitleTrackLoaded',
  // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag }
  SUBTITLE_FRAG_PROCESSED: 'hlsSubtitleFragProcessed',
  // fired when the first timestamp is found - data: { id : demuxer id, initPTS: initPTS, frag : fragment object }
  INIT_PTS_FOUND: 'hlsInitPtsFound',
  // fired when a fragment loading starts - data: { frag : fragment object }
  FRAG_LOADING: 'hlsFragLoading',
  // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded } }
  FRAG_LOAD_PROGRESS: 'hlsFragLoadProgress',
  // Identifier for fragment load aborting for emergency switch down - data: { frag : fragment object }
  FRAG_LOAD_EMERGENCY_ABORTED: 'hlsFragLoadEmergencyAborted',
  // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : { trequest, tfirst, tload, length } }
  FRAG_LOADED: 'hlsFragLoaded',
  // fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, payload : fragment payload, stats : { tstart, tdecrypt } }
  FRAG_DECRYPTED: 'hlsFragDecrypted',
  // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment }
  FRAG_PARSING_INIT_SEGMENT: 'hlsFragParsingInitSegment',
  // fired when parsing sei text is completed - data: { id : demuxer id, frag: fragment object, samples : [ sei samples pes ] }
  FRAG_PARSING_USERDATA: 'hlsFragParsingUserdata',
  // fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }
  FRAG_PARSING_METADATA: 'hlsFragParsingMetadata',
  // fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}
  FRAG_PARSING_DATA: 'hlsFragParsingData',
  // fired when fragment parsing is completed - data: { id : demuxer id, frag: fragment object }
  FRAG_PARSED: 'hlsFragParsed',
  // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id, frag : fragment object, stats : { trequest, tfirst, tload, tparsed, tbuffered, length, bwEstimate } }
  FRAG_BUFFERED: 'hlsFragBuffered',
  // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }
  FRAG_CHANGED: 'hlsFragChanged',
  // Identifier for a FPS drop event - data: { curentDropped, currentDecoded, totalDroppedFrames }
  FPS_DROP: 'hlsFpsDrop',
  // triggered when FPS drop triggers auto level capping - data: { level, droppedlevel }
  FPS_DROP_LEVEL_CAPPING: 'hlsFpsDropLevelCapping',
  // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data }
  ERROR: 'hlsError',
  // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example - data: { }
  DESTROYING: 'hlsDestroying',
  // fired when a decrypt key loading starts - data: { frag : fragment object }
  KEY_LOADING: 'hlsKeyLoading',
  // fired when a decrypt key loading is completed - data: { frag : fragment object, payload : key payload, stats : { trequest, tfirst, tload, length } }
  KEY_LOADED: 'hlsKeyLoaded',
  // fired upon stream controller state transitions - data: { previousState, nextState }
  STREAM_STATE_TRANSITION: 'hlsStreamStateTransition'
</code></pre>
<h2 id="兼容性">兼容性</h2>
<p>截至2018/7，它支持：</p>
<ul>
<li>Chrome for Android 34+</li>
<li>Chrome for Desktop 34+</li>
<li>适用于Android的Firefox 41+</li>
<li>Firefox for Desktop 42+</li>
<li>IE11 + for Windows 8.1+</li>
<li>Edge for Windows 10+</li>
<li>Opera for Desktop</li>
<li>Vivaldi for Desktop</li>
<li>Safari for Mac 8+（测试版）</li>
</ul>
<p>请注意：iOS Safari“Mobile”不支持MediaSource API。然而，Safari浏览器通过纯视频“标签”源URL支持内置的HLS支持。请参阅上面的示例（入门指南）运行适当的功能检测并选择使用Hls.js或本机内置的HLS支持。</p>
<p>当平台既没有MediaSource也没有本地HLS支持时，您将无法播放HLS。</p>
<h2 id="事件流">事件流</h2>
<p>由于内部通信都是基于 EventEmitter 来实现，透过事件流，你可以了解到代码运行的整体流程。</p>
<p>hls 整体流程如下：</p>
<figure data-type="image" tabindex="1"><img src="https://img.colabug.com/2017/11/382f3e53f4e662010efee1fd000feca8.png" alt="image" loading="lazy"></figure>
<p>hls实际会先通过 ajax（loader 是可以完成自定义的） 请求 m3u8文件，然后会读取到文件的分片列表，以及视频的编码格式，时长等。随后会按照顺序(非 seek )去对分片进行请求，这些也是通过 ajax 请求二进制的文件，然后借助 Media Source Extensions 将 buffer 内容进行合流，然后组成一个可播的媒体资源文件。</p>
<p>由于内部通过自定事件进行数据传递和流程控制，参考下面的图：</p>
<figure data-type="image" tabindex="2"><img src="https://img.colabug.com/2017/11/39ccf4fdcc416d91a5f1811b4561927d.png" alt="image" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mysql操作 (五) 之SQL 高级数据操作]]></title>
        <id>https://mengfanfan.github.io/post/mysql-cao-zuo-wu-zhi-sql-gao-ji-shu-ju-cao-zuo/</id>
        <link href="https://mengfanfan.github.io/post/mysql-cao-zuo-wu-zhi-sql-gao-ji-shu-ju-cao-zuo/">
        </link>
        <updated>2018-10-18T08:29:20.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇主要总结下mysql中的主键冲突、蠕虫复制、限制数量、查询条件判断、字段别名等使用方法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇主要总结下mysql中的主键冲突、蠕虫复制、限制数量、查询条件判断、字段别名等使用方法。</p>
<!-- more -->
<h1 id="数据高级操作">数据高级操作</h1>
<p>数据操作：增删改查</p>
<h2 id="1-新增数据">1、新增数据</h2>
<p>基本语法：</p>
<pre><code>insert into 表名 [(字段列表)] values(值列表);
</code></pre>
<p>在数据插入的时候，假设主键对应的值已经存在：插入一定会失败。</p>
<blockquote>
<p>主键冲突</p>
</blockquote>
<p>当主键存在冲突的时候(Duplicate key)，可以选择性的进行处理，更新和替换。</p>
<ul>
<li>
<p>主键冲突：更新操作</p>
<pre><code>insert into 表名 [(字段列表:包含主键] values(值列表) on duplicate key update 字段 = 新值;
</code></pre>
<p>例：</p>
<pre><code>-- 插入数据  第一个参数为主键
insert into my_calss values(&quot;php1&quot;,&quot;1&quot;);  -- 插入成功
insert into my_calss values(&quot;php1&quot;,&quot;2&quot;);  -- 插入失败 主键冲突

-- 主键冲突：更新
insert into my_class values(&quot;php1&quot;,&quot;2&quot;)
-- 冲突处理
on duplicate key update
-- 更新数据
room = '2';
</code></pre>
</li>
<li>
<p>主键冲突：替换</p>
<pre><code>replace into 表名 [(字段列表：包含主键)] values(值列表);
</code></pre>
<p>例：</p>
<pre><code>-- 主键冲突：替换
replace into my_calss values(&quot;php1&quot;,&quot;2&quot;);
</code></pre>
<p><strong>注意：</strong> 没有冲突则插入数据。有冲突替换。</p>
</li>
</ul>
<blockquote>
<p>蠕虫复制</p>
</blockquote>
<p>蠕虫复制：从已有的数据中去获取数据，然后将数据又进行新增操作：数据成倍的增加。</p>
<p>表创建高级操作：从已有表创建新表（复制表结构）</p>
<pre><code>create table 表名 like 数据库.表名;
</code></pre>
<pre><code>-- 复制创建表: 表结构复制，数据不复制
create table my_copy like mg_gbk;
</code></pre>
<p>蠕虫复制：先查出数据，然后将查出的数据新增一遍</p>
<pre><code>insert into 表名[(字段列表)] select 字段列表/* from 数据表名;
</code></pre>
<p>例：</p>
<pre><code>-- 蠕虫复制
insert into my_copy select * from my_collate_bin;  -- 复制别的表
insert into my_copy select * from my_copy;         -- 复制自己的表
</code></pre>
<p>蠕虫复制的意义：</p>
<ol>
<li>从已有表拷贝数据到新表中</li>
<li>可以迅速的让表中数据膨胀到一定的数量级，测试表的压力以及效率。</li>
</ol>
<h2 id="2-更新数据限制数量">2、更新数据(限制数量)</h2>
<p>基本语法：</p>
<pre><code>update 表名 set 字段 = 值 [where 条件];
</code></pre>
<p>高级新增语法：</p>
<pre><code>update 表名 set 字段 = 值 [where 条件][limit 更新数量];
</code></pre>
<p>例：更新部分数据</p>
<pre><code>--更新部分a变成c
update my_copy set name = 'c' where name = 'a' limit 3;
</code></pre>
<h2 id="3-删除数据">3、删除数据</h2>
<p>与更新类似，可以通过limit来限制数量。</p>
<pre><code>delete from 表名 [where 条件][limit 数量];
</code></pre>
<p>例：</p>
<pre><code>-- 删除数据：限制记录数为10
delete from my_copy where name = 'b' limit 10;
</code></pre>
<p>删除：如果表中存在主键自增长，那么当删除后，自增长不会还原。</p>
<p>思路：数据的删除是不会改变表结构，只能删除表后重建表。注意：表数据会被清空。只有表结构。</p>
<pre><code>truncate 表名;  -- 先删除改变，后新增改变。
</code></pre>
<p>例：</p>
<pre><code>-- 清空表：重置自增长
truncate my_student;
</code></pre>
<h2 id="4-查询数据">4、查询数据</h2>
<p>基本语法：</p>
<pre><code>select 字段列表/* from 表名 [where 条件];
</code></pre>
<p>完整语法：</p>
<pre><code>select [select 选项] 字段列表[字段别名]/* from 数据源 [where 条件子句][group by子句][having子句][order by 子句][limit 子句;
</code></pre>
<ol>
<li>
<p>select 选项<br>
含义: select对查出来的结果的处理方式</p>
<ul>
<li>all：默认的，保留所有的结果。</li>
<li>distinct：去重，查出来的结果，将重复的去除（所有字段都相同） 是对所有的字段进行去除</li>
</ul>
<pre><code>-- select选项  以下这俩表达的意思一样
select * from my_copy;
select all * from my_copy;
</code></pre>
<pre><code>-- 去重
select distinct * from my_copy;
</code></pre>
</li>
<li>
<p>字段别名</p>
<p>含义：当数据进行查询出来的时候，有时候名字并不一定就满足需求(多表查询的时候，会有同名字段) 需要对字段名进行重命名：别名。</p>
<p>基本语法：</p>
<pre><code>字段名 [as] 别名;  -- 加as或者不加as都行。
</code></pre>
<p>例：</p>
<pre><code>-- 字段别名
select
id,
number as 学号,
name as 姓名,
sex 性别 from my_student;
</code></pre>
</li>
<li>
<p>数据源</p>
<p>含义：数据的来源，关系型数据库的来源都是数据表，本质上只要保证数据类似二维表，最终都可以作为数据源。</p>
<p>数据源分为多种：单表数据源，多表数据源，查询语句</p>
<p>单表数据源：</p>
<pre><code>select * from 表名;
</code></pre>
<p>多表数据源：</p>
<pre><code>select * from 表名1,表名2，,...;
</code></pre>
<p>从一张表中取出一条记录，去另外一张表匹配所有记录，而且全部保留（记录数和字段数）将这种结果称为：笛卡尔积(交叉连接)。笛卡尔积没什么用，尽量避免使用。</p>
<p>子查询：数据的来源是一条查询语句(查询语句的结果是二维表)</p>
<pre><code>select * from (select 语句) as 表名;
</code></pre>
<p>例：</p>
<pre><code>-- 子查询
select * from (select * from my_student) as s;
</code></pre>
</li>
<li>
<p>where子句</p>
<p>where子句：用于判断数据，筛选数据。</p>
<p>where子句返回的结果：0或者1,  0代表false, 1代表true;</p>
<pre><code>select * from my_student where 1; -- 表示所有条件都满足，这种表达是为了语句的完整性。
</code></pre>
<p>判断条件：</p>
<ul>
<li>比较运算符：&gt;,&lt;,&gt;=,&lt;=,!=,&lt;&gt;,=,like,between,and,in/ont in</li>
<li>逻辑运算符：&amp;&amp;(and), ||(or), !(not)</li>
</ul>
<p>where原理：where是唯一一个直接从磁盘获取数据的时候就开始判断的条件：从磁盘取出一条记录，开始进行where判断，判断的结果，如果成立就保存到内存，如果失败就直接放弃。</p>
<p>条件查询1：</p>
<p>例：找出学生id为1,3,5的数据</p>
<pre><code>-- 找出学生id为1,3,5的数据， 以下两种语句结果一样
select * from my_student where id = 1 || id = 3 || id = 5; -- 逻辑判断
select * from my_student where id in(1,3,5); -- 落在集合中
</code></pre>
<p>条件查询2：</p>
<p>例：找身高在180到190之间的学生</p>
<pre><code>-- 找身高在180到190之间的学生，以下两种语句结果一样
select * from my_student where height &gt;= 180 and height &lt;= 190;
select * from my_student where height between 180 and 190;
</code></pre>
<p><strong>注意：</strong> between本身是闭区间，between左边的值必须小于等于右边的值</p>
</li>
<li>
<p>group by子句</p>
<p>group by：分组的意思，根据某个字段进行分组（相同的放一组，不同的分到不同的组）。</p>
<pre><code>-- 根据性别分组
select * from my_student group by sex;
</code></pre>
<p>分组的意思：是为了统计数据（按组统计：按分组字段进行数据统计）</p>
<p>SQL提供了一系列的统计函数</p>
<ul>
<li>count()：统计分组后的记录数：每一组有多少记录</li>
<li>max()：统计每组中最大的值</li>
<li>min()：统计最小值</li>
<li>avg()：统计平均值</li>
<li>sum()：统计和</li>
</ul>
<p>例：</p>
<pre><code>-- 分组统计：身高高矮，年龄平均和总年龄
select sex,count(*), max(height),min(height),avg(age),sum(age) from my_student group by sex;
</code></pre>
<p>count函数：里面可以使用两种参数：* 代表统计记录，字段名代表统计对应的字段(NULL不统计)</p>
<p>分组会自动排序：根据分组字段：默认升序</p>
<pre><code>-- asc：升序， desc：降序
group by 字段 [asc|desc]; -- 对分组的结果合并之后的整个结果进行排序。

</code></pre>
<p>例：</p>
<pre><code>select sex,count(*), max(height),min(height),avg(age),sum(age) from my_student group by sex desc;
</code></pre>
<p>多字段分组：先根据一个字段进行分组，然后对分组后的结果再次按照其他字段进行分组。</p>
<p>例：</p>
<pre><code>-- 多字段分组: 先班级，后男女
select c_id,sex,count(*) from my_student group by c_id,sex; -- 多字段排序
</code></pre>
<p>有一个函数：可以对分组的结果中某个字段进行字符串连接(保留该组所有的某个字段)</p>
<pre><code>group_concat(字段);
</code></pre>
<p>例：</p>
<pre><code>-- 多字段分组: 先班级，后男女
select c_id,sex,count(*),group_concat(name) from my_student group by c_id,sex; -- 多字段排序
</code></pre>
<p>回溯统计：with rollup; 任何一个分组后都会有一个小组，最后都需要向上级分组进行汇报统计，根据当前分组的字段。这就是回溯统计。特点：回溯统计的时候会将分组字段置空。</p>
<pre><code>-- 统计
select c_id,count(*) from my_student group by c_id;

-- 回溯统计
select c_id,count(*) from my_student group by c_id with rollop;

-- 多字段分组回溯统计
select c_id,sex,count(*),group_concat(name) from my_student group by c_id,sex; -- 多字段排序
select c_id,sex,count(*),group_concat(name) from my_student group by c_id,sex with rollop; -- 多字段分组回溯统计
</code></pre>
<p>多字段回溯：考虑第一层分组会有一次回溯，第二次分组要看第一次分组的组数，组数是多少，回溯就是多少，然后再加上第一层回溯即可。</p>
</li>
<li>
<p>having子句</p>
</li>
<li>
<p>order by子句</p>
</li>
<li>
<p>limit子句</p>
</li>
</ol>
<p>含义：limit子句是一种限制结果的语句：限制数量</p>
<p>limit有两种使用方式：</p>
<p>方案1：只用来限制长度(数据量)：limit数据量；</p>
<p>例：</p>
<pre><code>--查询学生：前两个
select * from my_student limit 2;
</code></pre>
<p>方案2：限制起始位置，限制数量：limit 起始位置,限制数;</p>
<p>例：</p>
<pre><code>-- 查询学生：前两个
select * from my_student limit 0,2; -- 记录数是从0开始编号
</code></pre>
<p>limit 方案2：主要用来实现数据的分页：为用户节省时间，提高服务器的响应效率，减少资源的浪费。</p>
<p>对于用户来讲：可以点击的分页按钮1,2,3,4</p>
<p>对于服务器来讲，根据用户选择的页码来获取不同的数据：limit offset,length;</p>
<p>length:每页显示的数据量：基本不变。</p>
<p>offset: offset=(页码 - 1) * 每页显示量</p>
<p>分页查询语句及获取总记录数</p>
<pre><code>select SQL_CALC_FOUND_ROWS  * from bloglist order by id limit 2,2;
SELECT FOUND_ROWS();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mysql操作 (四) 之SQL 中文数据问题]]></title>
        <id>https://mengfanfan.github.io/post/mysql-cao-zuo-si-zhi-sql-zhong-wen-shu-ju-wen-ti/</id>
        <link href="https://mengfanfan.github.io/post/mysql-cao-zuo-si-zhi-sql-zhong-wen-shu-ju-wen-ti/">
        </link>
        <updated>2018-10-15T08:28:24.000Z</updated>
        <summary type="html"><![CDATA[<p>SQL 里中文数据问题的本质是字符集问题。计算机只能识别二进制，人类更多的是识别符号；需要有一个二进制与字符的对应关系（字符集）...</p>
]]></summary>
        <content type="html"><![CDATA[<p>SQL 里中文数据问题的本质是字符集问题。计算机只能识别二进制，人类更多的是识别符号；需要有一个二进制与字符的对应关系（字符集）...</p>
<!-- more -->
<h2 id="中文数据问题">中文数据问题</h2>
<p>中文数据问题的本质是字符集问题。</p>
<p>计算机只能识别二进制，人类更多的是识别符号；需要有一个二进制与字符的对应关系（字符集）；</p>
<p>客户端向服务器插入中文数据没有成功。</p>
<pre><code>--插入中文数据
insert into my_student values(5,'ddd','张越','猫');  // 报错
</code></pre>
<p>原因：\xD5\xD5\xD4\xBD 代表的是“张越”在当前编码（字符集）下对应的二进制编码转换成的十六进制：两个汉字 =》 四个字节（GBK）</p>
<p>报错：服务器没有识别对应的四个字节：服务器认为数据是UTF8，一个汉字有三个字节；读取三个字节转换成汉字（失败），剩余的再读三个字节（不够）；最终失败。</p>
<p>所有的数据库服务器认为（表现）的一些特性都是通过服务器端的变量来保存；系统先读取自己的变量，看看应该怎么表现。</p>
<p>// 查看服务器到底识别哪些字符集</p>
<pre><code>-- 查看所有字符集
show character set;
</code></pre>
<p>基本上：服务器是万能的，什么字符集都支持。</p>
<p>// 既然服务器识别这么多，总有一种是服务器默认与客户端打交道的字符集</p>
<pre><code>-- 查看服务器默认的对外处理的字符集
show variables like 'character_set%';
</code></pre>
<p>问题根源：客户端数据只能是GBK，而服务器认为是UTF8;矛盾产出。</p>
<p>解决方案：改变服务器，默认的接受字符集为GBK；</p>
<pre><code>-- 修改服务器认为的客户端数据的字符集为GBK
set character_set_client = gbk;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js 判断数据类型四种方法]]></title>
        <id>https://mengfanfan.github.io/post/js-pan-duan-shu-ju-lei-xing-si-chong-fang-fa/</id>
        <link href="https://mengfanfan.github.io/post/js-pan-duan-shu-ju-lei-xing-si-chong-fang-fa/">
        </link>
        <updated>2018-10-10T08:30:44.000Z</updated>
        <summary type="html"><![CDATA[<p>鉴于 js 是松散类型的，因此需有一种手段来检测给定变量的数据类型。对此Js 也提供多种方法，但遗憾的是，不同的方法得到的结果参差不齐。</p>
]]></summary>
        <content type="html"><![CDATA[<p>鉴于 js 是松散类型的，因此需有一种手段来检测给定变量的数据类型。对此Js 也提供多种方法，但遗憾的是，不同的方法得到的结果参差不齐。</p>
<!-- more -->
<h2 id="1-typeof">1、typeof</h2>
<p>typeof 是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 7 种：number、boolean、symbol、string、object、undefined、function 等。</p>
<pre><code>   typeof ''; // string 有效
   typeof 1; // number 有效
   typeof Symbol(); // symbol 有效
   typeof true; //boolean 有效
   typeof undefined; //undefined 有效
   typeof null; //object 无效
   typeof [] ; //object 无效
   typeof new Function(); // function 有效
   typeof new Date(); //object 无效
   typeof new RegExp(); //object 无效
</code></pre>
<h2 id="2-instanceof">2、instanceof</h2>
<p>instanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：instanceof 检测的是原型</p>
<pre><code>   [] instanceof Array; // true
   {} instanceof Object;// true
   new Date() instanceof Date;// true
    
   function Person(){};
   new Person() instanceof Person;
    
   [] instanceof Object; // true
   new Date() instanceof Object;// true
   new Person instanceof Object;// true
</code></pre>
<h2 id="3-constructor">3、constructor</h2>
<p>对象的constructor属性用于返回创建该对象的函数</p>
<pre><code>   var test=new Array();
   
   if (test.constructor==Array)
   {
   document.write(&quot;This is an Array&quot;);
   }
   if (test.constructor==Boolean)
   {
   document.write(&quot;This is a Boolean&quot;);
   }
   if (test.constructor==Date)
   {
   document.write(&quot;This is a Date&quot;);
   }
   if (test.constructor==String)
   {
   document.write(&quot;This is a String&quot;);
   }
</code></pre>
<blockquote>
<p>细节问题：</p>
</blockquote>
<ol>
<li>
<p>null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。</p>
</li>
<li>
<p>函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object</p>
</li>
</ol>
<h2 id="4-tostring">4、toString</h2>
<p>toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。</p>
<p>对于 Object 对象，直接调用 toString()  就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。</p>
<pre><code>    Object.prototype.toString.call('') ;   // [object String]
    Object.prototype.toString.call(1) ;    // [object Number]
    Object.prototype.toString.call(true) ; // [object Boolean]
    Object.prototype.toString.call(Symbol()); //[object Symbol]
    Object.prototype.toString.call(undefined) ; // [object Undefined]
    Object.prototype.toString.call(null) ; // [object Null]
    Object.prototype.toString.call(new Function()) ; // [object Function]
    Object.prototype.toString.call(new Date()) ; // [object Date]
    Object.prototype.toString.call([]) ; // [object Array]
    Object.prototype.toString.call(new RegExp()) ; // [object RegExp]
    Object.prototype.toString.call(new Error()) ; // [object Error]
    Object.prototype.toString.call(document) ; // [object HTMLDocument]
    Object.prototype.toString.call(window) ; //[object global] window 是全局对象 global 的引用
</code></pre>
<p>方法：</p>
<pre><code>export const typeExamine = (value: any) =&gt; {
  return Reflect.apply(Object.prototype.toString, value, [])
    .replace(/^\[object\s(\w+)\]$/, &quot;$1&quot;)
    .toLowerCase();
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mysql操作 (三) 之SQL 数据操作]]></title>
        <id>https://mengfanfan.github.io/post/mysql-cao-zuo-san-zhi-sql-shu-ju-cao-zuo/</id>
        <link href="https://mengfanfan.github.io/post/mysql-cao-zuo-san-zhi-sql-shu-ju-cao-zuo/">
        </link>
        <updated>2018-10-04T08:26:26.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇主要介绍mysql中的数据操作，一些基础的增删改查，常规的使用方法，一起来看吧。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇主要介绍mysql中的数据操作，一些基础的增删改查，常规的使用方法，一起来看吧。</p>
<!-- more -->
<h2 id="sql-数据操作">SQL 数据操作</h2>
<blockquote>
<p>新增数据</p>
</blockquote>
<p>有两种方案</p>
<p><strong>方案1：</strong> 给全表字段插入数据，不需要指定字段列表</p>
<p>要求：要求数据的值出现的顺序必须与表中设计的字段出现的顺序一致，凡事非数值数据，都需要使用引号（建议是单引号）包裹。</p>
<p>基本语法：</p>
<pre><code>insert into 表名 values(值列表)[,值列表]; -- 可以一次性插入多条数据
</code></pre>
<p>例：</p>
<pre><code>-- 插入数据
insert into my_student values(1,'inst111','jim','male'),((2,'inst222','jsse','male');  
</code></pre>
<p><strong>方案2：</strong> 给部分字段插入数据，需要选定字段列表，字段列表出现顺序与字段的顺序无关；但是值列表的顺序必须与选定的字段的顺序一致。</p>
<p>基本语法：</p>
<pre><code>insert into 表名 (字段列表) values(值列表)[,值列表]; 
</code></pre>
<p>例：</p>
<pre><code>-- 插入数据：指定字段列表
insert into my_student (number,sex,name,id) values
('ictast001','male','tom',3),
('ictast002','male','lily',4);
</code></pre>
<blockquote>
<p>查看数据</p>
</blockquote>
<p>基本语法：</p>
<pre><code>select */字段列表 from 表名 [where 条件];
</code></pre>
<p>例：</p>
<pre><code>-- 查看所有数据
select * from my_student;

-- 查看指定字段，指定条件数据
select id,number,sex from my_student where id=1; -- 查看满足id为1的数据
</code></pre>
<blockquote>
<p>更新数据</p>
</blockquote>
<p>基本语法：</p>
<pre><code>update 表名 set 字段 = 值 [where 条件]; -- 建议都有where，要不加更新全部
</code></pre>
<p>例：<br>
本篇主要介绍mysql中的数据操作，一些基础的增删改查，常规的使用方法，一起来看吧。</p>
<!-- more -->
<pre><code>-- 更新数据
update my_student set sex = 'female' where name = 'jim';
</code></pre>
<p>初始<br>
更新不一定会成功，如没有真正要更新的数据。如果该数据的初始值为1，更新该数据还为1，那并没有真正更新该数据。判断数据更新成功，需要看受影响的行数。</p>
<blockquote>
<p>删除数据</p>
</blockquote>
<p>基本语法：</p>
<pre><code>delete from 表名 [where 条件];
</code></pre>
<p>例：</p>
<pre><code>-- 删除数据
delete from my_student where sex = 'male';
</code></pre>
<p><strong>注意：</strong> 删除不可逆，谨慎删除。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mysql操作 (二) 之SQL 表操作（字段）]]></title>
        <id>https://mengfanfan.github.io/post/mysql-cao-zuo-er-zhi-sql-biao-cao-zuo-zi-duan/</id>
        <link href="https://mengfanfan.github.io/post/mysql-cao-zuo-er-zhi-sql-biao-cao-zuo-zi-duan/">
        </link>
        <updated>2018-09-23T08:25:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="sql-表操作字段">SQL 表操作（字段）</h2>
<blockquote>
<p>新增数据表</p>
</blockquote>
<p>基本语法:</p>
<pre><code>create table [if not exists] 表名(
字段名字 数据类型,
字段名字 数据类型       -- 最后一行不需要逗号
)[表选项];
</code></pre>
<p><strong>解释：</strong></p>
<p>if not exists：如果表名不存在，那么创建，否则不执行创建代码（检查功能）</p>
<p>表选项：控制表的表现</p>
<p>字符集：charset/charset set 具体字符集;  -- 保证表中数据存储的字符集</p>
<p>校对集：collate 具体校对集；</p>
<p>存储引擎：engine 具体的存储引擎（innodb 和 myisam）</p>
<p>任何一个表的设计都必须指定数据库。</p>
<ol>
<li>
<p>方案1：:显示的指定表所属的数据库</p>
<pre><code>create tabe 数据库名.表名();  -- 将当期数据表创建到指定的数据库中
</code></pre>
<p>例：</p>
<pre><code> -- 创建数据表
 create table if not exists mydatabase.student(  -- 显示的student表放到mydatabase数据库下
    name varchar(10),
    gender varchar(12),
    number int
    age int
 )charset utf8;
</code></pre>
</li>
<li>
<p>方案2：隐式的指定表所属数据库：先进入到某个数据库环境，然后这样创建的表自动归属到某个指定的数据库。</p>
<p>进入数据库环境：use 数据库名字;</p>
<p>例：</p>
<pre><code>-- 创建数据表
-- 进入数据库
use mydatabase;

-- 创建表
create table class(
name varchar(10),
room varchar(10)
)charset utf8;
</code></pre>
<p>当创建数据表的SQL指令执行之后，发生了什么？</p>
<ul>
<li>指定数据库下已存在对应的表</li>
<li>在数据库对应的文件夹下，会产生对应表的数据结构文件（跟存储引擎有关系）</li>
</ul>
</li>
</ol>
<blockquote>
<p>查看数据表</p>
</blockquote>
<ol>
<li>
<p>查看所有表</p>
<p>基本语法：</p>
<pre><code>show tables;
</code></pre>
</li>
<li>
<p>查看部分表：模糊匹配</p>
<p>基本语法：</p>
<pre><code>show tables like 'pattern';
</code></pre>
<p>例：</p>
<pre><code>--查看以s结尾的表
show table like '%s';
</code></pre>
</li>
<li>
<p>查看表创建语句</p>
<p>基本语法：</p>
<pre><code>show create table 表名;
</code></pre>
<p>例：</p>
<pre><code>--  查看表创建语句
show create table student\g  -- \g 等同于 ;
show create table student\G  -- 将查到的结构旋转90度变成纵向。
</code></pre>
</li>
<li>
<p>查看表结构：查看表中的字段信息</p>
</li>
</ol>
<p>基本语法：</p>
<pre><code>~~~
desc/describe/show columns from 表名;
~~~

例：

~~~
-- 查看表结构
desc calss;
describe calss;
show columns from class;  // 以上三种语法表达的意思都一样
~~~
</code></pre>
<blockquote>
<p>修改数据表</p>
</blockquote>
<p>表本身存在，还包含字段：表的修改包含两部分：修改表本身和修改字段。</p>
<ol>
<li>修改表本身</li>
</ol>
<p>表本身可以修改：表名和表选项</p>
<ul>
<li>
<p>修改表名：</p>
<pre><code>rename table 老表名 to 新表名;
</code></pre>
</li>
<li>
<p>修改表选项：字符集、校对集和存储引擎</p>
<pre><code>alter table 表名 表选项 [=] 值;
</code></pre>
<p>例：</p>
<pre><code>-- 修改表选项：字符集
alter table my_student clarset = GBK;
</code></pre>
</li>
</ul>
<ol start="2">
<li>修改字段</li>
</ol>
<p>字段操作很多：新增，修改，重名，删除</p>
<ul>
<li>
<p>新增字段：</p>
<pre><code>alter table 表名 add [column] 字段名 数据类型 [列属性][位置];

位置：字段名可以存放表中任意位置
    first：第一个位置
    after：在哪个字段之后：after字段名；默认的是在最后一个字段之后。
</code></pre>
<p>例：</p>
<pre><code>-- 给学生表增加ID放在第一个位置
alter table my_student add column id int first;
</code></pre>
</li>
<li>
<p>修改字段：修改通常是修改属性或者数据类型</p>
<pre><code>alter table 表名 modify 字段名 数据类型 [属性][位置];
</code></pre>
<p>例：</p>
<pre><code>-- 将学生表中的number学号字段变成固定长度，且放到第二位（id之后）
alter table my_student modify number char(10) after id;
</code></pre>
</li>
<li>
<p>重命名字段</p>
<pre><code>alter table 表名 change 旧字段 新字段 数据类型 [属性][位置];
</code></pre>
<p>例：</p>
<pre><code>-- 修改学生表中的 gender字段为sex
alter table my_student change gender sex varchar(10);
</code></pre>
</li>
<li>
<p>删除字段</p>
<pre><code>alter table 表名 drop 字段名;
</code></pre>
</li>
</ul>
<p><strong>小心：</strong>  如果表中已经存在数据，那么删除字段会清空该字段的所有数据（不可逆）</p>
<blockquote>
<p>删除数据表</p>
</blockquote>
<p>基本语法：</p>
<pre><code>drop table 表名1,表名2;  --可以一次性删除多张表
</code></pre>
<p>当删除数据表的指令执行后发生了什么？</p>
<ul>
<li>在表空间中，没有了指定的表（数据也没有了）</li>
<li>在数据库对应的文件夹下，表对应的文件（与存储引擎有关）也删除了。</li>
</ul>
<p>注意：删除有危险操作需谨慎（不可逆）</p>
]]></content>
    </entry>
</feed>
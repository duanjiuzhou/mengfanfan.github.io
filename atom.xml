<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://duanjiuzhou.github.io/mengff.github.io/</id>
    <title>孟饭饭的独立博客</title>
    <updated>2020-08-04T10:07:02.364Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://duanjiuzhou.github.io/mengff.github.io/"/>
    <link rel="self" href="https://duanjiuzhou.github.io/mengff.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://duanjiuzhou.github.io/mengff.github.io/images/avatar.png</logo>
    <icon>https://duanjiuzhou.github.io/mengff.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 孟饭饭的独立博客</rights>
    <entry>
        <title type="html"><![CDATA[js 判断数据类型四种方法]]></title>
        <id>https://duanjiuzhou.github.io/mengff.github.io/post/js-pan-duan-shu-ju-lei-xing-si-chong-fang-fa/</id>
        <link href="https://duanjiuzhou.github.io/mengff.github.io/post/js-pan-duan-shu-ju-lei-xing-si-chong-fang-fa/">
        </link>
        <updated>2020-08-04T08:30:44.000Z</updated>
        <summary type="html"><![CDATA[<p>鉴于 js 是松散类型的，因此需有一种手段来检测给定变量的数据类型。对此Js 也提供多种方法，但遗憾的是，不同的方法得到的结果参差不齐。</p>
]]></summary>
        <content type="html"><![CDATA[<p>鉴于 js 是松散类型的，因此需有一种手段来检测给定变量的数据类型。对此Js 也提供多种方法，但遗憾的是，不同的方法得到的结果参差不齐。</p>
<!-- more -->
<h2 id="1-typeof">1、typeof</h2>
<p>typeof 是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 7 种：number、boolean、symbol、string、object、undefined、function 等。</p>
<pre><code>   typeof ''; // string 有效
   typeof 1; // number 有效
   typeof Symbol(); // symbol 有效
   typeof true; //boolean 有效
   typeof undefined; //undefined 有效
   typeof null; //object 无效
   typeof [] ; //object 无效
   typeof new Function(); // function 有效
   typeof new Date(); //object 无效
   typeof new RegExp(); //object 无效
</code></pre>
<h2 id="2-instanceof">2、instanceof</h2>
<p>instanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：instanceof 检测的是原型</p>
<pre><code>   [] instanceof Array; // true
   {} instanceof Object;// true
   new Date() instanceof Date;// true
    
   function Person(){};
   new Person() instanceof Person;
    
   [] instanceof Object; // true
   new Date() instanceof Object;// true
   new Person instanceof Object;// true
</code></pre>
<h2 id="3-constructor">3、constructor</h2>
<p>对象的constructor属性用于返回创建该对象的函数</p>
<pre><code>   var test=new Array();
   
   if (test.constructor==Array)
   {
   document.write(&quot;This is an Array&quot;);
   }
   if (test.constructor==Boolean)
   {
   document.write(&quot;This is a Boolean&quot;);
   }
   if (test.constructor==Date)
   {
   document.write(&quot;This is a Date&quot;);
   }
   if (test.constructor==String)
   {
   document.write(&quot;This is a String&quot;);
   }
</code></pre>
<blockquote>
<p>细节问题：</p>
</blockquote>
<ol>
<li>
<p>null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。</p>
</li>
<li>
<p>函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object</p>
</li>
</ol>
<h2 id="4-tostring">4、toString</h2>
<p>toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。</p>
<p>对于 Object 对象，直接调用 toString()  就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。</p>
<pre><code>    Object.prototype.toString.call('') ;   // [object String]
    Object.prototype.toString.call(1) ;    // [object Number]
    Object.prototype.toString.call(true) ; // [object Boolean]
    Object.prototype.toString.call(Symbol()); //[object Symbol]
    Object.prototype.toString.call(undefined) ; // [object Undefined]
    Object.prototype.toString.call(null) ; // [object Null]
    Object.prototype.toString.call(new Function()) ; // [object Function]
    Object.prototype.toString.call(new Date()) ; // [object Date]
    Object.prototype.toString.call([]) ; // [object Array]
    Object.prototype.toString.call(new RegExp()) ; // [object RegExp]
    Object.prototype.toString.call(new Error()) ; // [object Error]
    Object.prototype.toString.call(document) ; // [object HTMLDocument]
    Object.prototype.toString.call(window) ; //[object global] window 是全局对象 global 的引用
</code></pre>
<p>方法：</p>
<pre><code>export const typeExamine = (value: any) =&gt; {
  return Reflect.apply(Object.prototype.toString, value, [])
    .replace(/^\[object\s(\w+)\]$/, &quot;$1&quot;)
    .toLowerCase();
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【转】CSS垂直居中技巧，我只会23个，你会几个？]]></title>
        <id>https://duanjiuzhou.github.io/mengff.github.io/post/zhuan-css-chui-zhi-ju-zhong-ji-qiao-wo-zhi-hui-23-ge-ni-hui-ji-ge/</id>
        <link href="https://duanjiuzhou.github.io/mengff.github.io/post/zhuan-css-chui-zhi-ju-zhong-ji-qiao-wo-zhi-hui-23-ge-ni-hui-ji-ge/">
        </link>
        <updated>2020-08-04T08:30:17.000Z</updated>
        <summary type="html"><![CDATA[<p>自古以来(是有多?~)，网页CSS的垂直居中需求始终没有停过，而其困难度也始终没有让人轻松过，经过了每位开发先烈的研究后，据说...</p>
]]></summary>
        <content type="html"><![CDATA[<p>自古以来(是有多?~)，网页CSS的垂直居中需求始终没有停过，而其困难度也始终没有让人轻松过，经过了每位开发先烈的研究后，据说...</p>
<!-- more -->
<p>自古以来(是有多?~)，网页CSS的垂直居中需求始终没有停过，而其困难度也始终没有让人轻松过，经过了每位开发先烈的研究后，据说CSS的垂直居中技巧已达到近十种之多，但始终鲜为人知，部分公司甚至将CSS的垂直居中技巧当成面试题，其重要性可见一斑，经过了Amos通灵了一下之后把垂直居中的写法扩展到了23种，今天就让Amos带着大家轻松的了解一下CSS的垂直居中的方式吧。</p>
<h2 id="1-line-height">1、Line-height</h2>
<blockquote>
<p>适用情景：单行文字垂直居中技巧</p>
</blockquote>
<p>这个方式应该是最多人知道的了，常见于单行文字的应用，像是按钮这一类对象，或者是下拉框、导航此类元素最常见到的方式了。此方式的原理是在于将单行文字的行高设定后，文字会位于行高的垂直中间位置，利用此原理就能轻松达成垂直居中的需求了。</p>
<pre><code>&lt;div class=&quot;content&quot;&gt;Lorem ipsam.&lt;/div&gt;
.content{
  width: 400px;
  background: #ccc;
  line-height:100px;
  margin: auto;
}
</code></pre>
<h2 id="2-line-height-inline-block">2、Line-height + inline-block</h2>
<blockquote>
<p>适用情景：多对象的垂直居中技巧</p>
</blockquote>
<p>既然可以使用第一种方式对行元素达成垂直居中的话，当然没有理由不能做到多行啊~但是你需要将多个元素或多行元素当成一个行元素来看待，所以我们必须要将这些数据多包一层，并将其设定为inline-block，并在该inline-block对象的外层对象使用inline-block来代替height的设置，如此便可以达到垂直居中的目的了，从使你的数据是包含了标题跟内容在内也可以正常的垂直居中了。</p>
<pre><code>&lt;div class=&quot;box box2&quot;&gt;
  &lt;div class=&quot;content&quot;&gt;
    立马来看Amos实际完成的    &lt;a href=&quot;http://csscoke.com/2015/07/31/nth-child_rwd_album/&quot;&gt;
      CSS3精美相册效果    &lt;/a&gt;
    效果吧！別忘了拖拉一下窗口看看 RWD 效果喔！  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code>h2{
  text-align: center;
}
.box{
  width: 500px;
  border: 1px solid #f00;
  margin: auto;
  line-height: 200px;
  text-align: center;
}
.box2 .content{
  display: inline-block;
  height: auto;
  line-height:1;
  width: 400px;
  background: #ccc;
}
</code></pre>
<h2 id="3-before-inline-block">3、:before + inline-block</h2>
<blockquote>
<p>适用情景：多对象的CSS垂直居中技巧</p>
</blockquote>
<p>:before 伪类元素搭配 inline-block 属性的写法应该是很传统的垂直居中的技巧了，此方式的好处在于子元素居中可以不需要特别设定高度，我们将利用:before伪类元素设定为100%高的inline-block，再搭配上将需要居中的子元素同样设置成inline-block性质后，就能使用vertical-align:middle来达到垂直居中的目的了，此方式在以往其实是个非常棒的垂直居中解决方案，唯独需要特别处理掉inline-block元素之间的4-5px空间这个小缺陷，但也很实用了。</p>
<pre><code>&lt;h2&gt;3.:before + inline-block&lt;/h2&gt;
&lt;div class=&quot;box box3&quot;&gt;
  &lt;div class=&quot;content&quot;&gt;
    立马来看Amos实际完成的    &lt;a href=&quot;http://csscoke.com/2015/07/31/nth-child_rwd_album/&quot;&gt;
      CSS3精美相册效果    &lt;/a&gt;
    效果吧！別忘了拖拉一下窗口看看 RWD 效果喔！  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code>h2{
  text-align: center;
}
.box{
  width: 500px;
  height: 250px;
  border: 1px solid #f00;
  margin: auto;
  text-align: center;
}
.box::before{
  content:'';
  display: inline-block;
  height: 100%;
  width: 0;
  vertical-align: middle;
}
.box .content{
  width: 400px;
  background: #ccc;
  display: inline-block;
  vertical-align: middle;
}
</code></pre>
<h2 id="4-absolute-margin-负值">4、absolute + margin 负值</h2>
<blockquote>
<p>适用情景：多行文字的垂直居中技巧</p>
</blockquote>
<p>谁说绝对定位要少用？Amos认为没有少用多用的问题，重点在于你是否有妥善运用才是重点，绝对定位在这个例子中会设置top:50%来抓取空间高度的50%，接着在将居中元素的margin-top设定为负一半的高度，这样就能让元素居中了，此方法可是自古以来流传多年的居中方式呢？</p>
<pre><code>&lt;h2&gt;4.absolute + margin 負值&lt;/h2&gt;
&lt;div class=&quot;box box4&quot;&gt;
  &lt;div class=&quot;content&quot;&gt;
    立马来看Amos实际完成的    &lt;a href=&quot;http://csscoke.com/2015/07/31/nth-child_rwd_album/&quot;&gt;
      CSS3精美相册效果    &lt;/a&gt;
    效果吧！別忘了拖拉一下窗口看看 RWD 效果喔！  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code>h2{
  text-align: center;
}
.box{
  width: 500px;
  height: 250px;
  border: 1px solid #f00;
  margin: auto;
  position: relative;
}
.box4 .content{
  width: 400px;
  background: #ccc;
  height: 70px;
  position: absolute;
  top:50%;
  left: 50%;
  margin-left: -200px;
  margin-top: -35px;
}
</code></pre>
<h2 id="5-absolute-margin-auto">5、absolute + margin auto</h2>
<blockquote>
<p>适用情景：多行文字的垂直居中技巧</p>
</blockquote>
<p>又一个绝对定位的垂直居中的方案，这个方式比较特别一点，当元素设置为绝对定位后，假设它是抓不到整体可运用的空间范围，所以margin:auto会失效，但当你设置了top:0;bottom:0;时，绝对定位元素就抓到了可运用的空间了，这时你的margin:auto就生效了（神奇吧），如果你的绝对定位元素需要水平居中于父层，那你同样可以设定left:0;right:0;来让绝对定位元素取得空间可运用范围，再让marign-left与margin-right设定为auto即可居中。但此方式的缺点是你的定位元素必须有固定的宽高（百分比也算）才能正常居中。</p>
<pre><code>&lt;h2&gt;5.absolute + translate(-50%, -50%)&lt;/h2&gt;
&lt;div class=&quot;box box5&quot;&gt;
  &lt;div class=&quot;content&quot;&gt;
    立马来看Amos实际完成的    &lt;a href=&quot;http://csscoke.com/2015/07/31/nth-child_rwd_album/&quot;&gt;
      CSS3精美相册效果    &lt;/a&gt;
    效果吧！別忘了拖拉一下窗口看看 RWD 效果喔！  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code>h2{
  text-align: center;
}
.box{
  width: 500px;
  height: 250px;
  border: 1px solid #f00;
  margin: auto;
  position: relative;
}
.content{
  width: 400px;
  background: #ccc;
  height: 70px;
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  margin: auto;
}
</code></pre>
<h2 id="6-absolute-translate">6、absolute + translate</h2>
<blockquote>
<p>适用情景：多行文字的垂直居中技巧</p>
</blockquote>
<p>在一个绝对定位居中的方式，此方式应该算是最方便的了，因为此居中的定位元素不需要固定的宽高，我们利用绝对定位时的top 与right设置元素的上方跟左方各为50%，再利用translate(-50%,-50%)位移居中元素自身宽与高的50%就能达成居中的目的了。（css3好棒）</p>
<pre><code>&lt;h2&gt;6.absolute + margin: auto&lt;/h2&gt;
&lt;div class=&quot;box box6&quot;&gt;
  &lt;div class=&quot;content&quot;&gt;
    立马来看Amos实际完成的    &lt;a href=&quot;http://csscoke.com/2015/07/31/nth-child_rwd_album/&quot;&gt;
      CSS3精美相册效果    &lt;/a&gt;
    效果吧！別忘了拖拉一下窗口看看 RWD 效果喔！  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code>h2{
  text-align: center;
}
.box{
  width: 500px;
  height: 250px;
  border: 1px solid #f00;
  margin: auto;
  position: relative;
}
.box5 .content{
  width: 400px;
  background: #ccc;
  position: absolute;
  top:50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
</code></pre>
<h2 id="7flex-align-items">7.Flex + align-items</h2>
<blockquote>
<p>适用情景：多行文字的垂直居中技巧</p>
</blockquote>
<p>Flex！前端的毒品！后端的宝物！这东西自从面世之后就不断的考验网页开发者的良心，到底要不要抛弃float拥抱flex，我想这答案人人心中自由一把尺，但先碰Flex再碰Float可谓先甜后苦，这顺序到底要倒吃甘蔗还是正吃甘蔗是实在难说，自从有了Flex之后，小孩考试一百分，设计网页不跑版，客户网页都RWD，老板赚钱好开心，我也加薪（加班）好甘心，不由的说Flex真的是一个神物，我们只要设定父层display:flex以及设定次轴(cross axis)属性align-items:center 就好了（说那么多结果重点就一行字是哪招啦），这个方式的优点是此层不需要设定高度即可自动居中，且原始代码干净无比，真的是用一次就让你升天啦。</p>
<pre><code>&lt;h2&gt;7.Flex + align-items&lt;/h2&gt;
&lt;div class=&quot;box box7&quot;&gt;
  &lt;div class=&quot;content&quot;&gt;
    立马来看Amos实际完成的    &lt;a href=&quot;http://csscoke.com/2015/07/31/nth-child_rwd_album/&quot;&gt;
      CSS3精美相册效果    &lt;/a&gt;
    效果吧！別忘了拖拉一下窗口看看 RWD 效果喔！  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code>h2{
  text-align: center;
}
.box{
  width: 500px;
  height: 250px;
  border: 1px solid #f00;
  margin: auto;
  display: flex;
  justify-content: center;
  align-items: center; 
}
.content{
  width: 400px;
  background: #ccc;
}
</code></pre>
<h2 id="8-flex-before-flex-grow">8、Flex + :before + flex-grow</h2>
<blockquote>
<p>适用情景：多行文字的垂直居中技巧</p>
</blockquote>
<p>Flex有多种方式可以让你把数据居中，适用Flex-grow的延展特性来达成，这个例子中Amos适用了flex-direction:column直式排法，搭配:before伪元素适用flex-grow伸展值能够取得剩下所有空间的特性，把它设定成一半的剩余空间就能做到把内容数据准确的推到垂直中间位置，算是个传统技法的延伸方式。这样的话上面第七个方式不是比较快？</p>
<pre><code>&lt;h2&gt;8.Flex + before + flex-grow&lt;/h2&gt;
&lt;div class=&quot;box box8&quot;&gt;
  &lt;div class=&quot;content&quot;&gt;
    立马来看Amos实际完成的    &lt;a href=&quot;http://csscoke.com/2015/07/31/nth-child_rwd_album/&quot;&gt;
      CSS3精美相册效果    &lt;/a&gt;
    效果吧！別忘了拖拉一下窗口看看 RWD 效果喔！  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code>h2{
  text-align: center;
}
.box{
  width: 500px;
  height: 250px;
  border: 1px solid #f00;
  margin: auto;
  display: flex;
  flex-direction: column;
  align-items: center;
}
.box:before{
  content: '';
  flex-grow: .5;
}
.content{
  width: 400px;
  background: #ccc;
}
</code></pre>
<h2 id="9-flex-margin">9、Flex + margin</h2>
<blockquote>
<p>适用情景：多行文字的垂直居中技巧</p>
</blockquote>
<p>继续用Flex来居中，由于Flex元素对空间解读的特殊性，我们只要在父层元素设定display:flex，接着在需要垂直居中的元素上设定margin:auto，即可自动居中</p>
<pre><code>&lt;h2&gt;9.Flex + margin&lt;/h2&gt;
&lt;div class=&quot;box box9&quot;&gt;
  &lt;div class=&quot;content&quot;&gt;
    立马来看Amos实际完成的    &lt;a href=&quot;http://csscoke.com/2015/07/31/nth-child_rwd_album/&quot;&gt;
      CSS3精美相册效果    &lt;/a&gt;
    效果吧！別忘了拖拉一下窗口看看 RWD 效果喔！  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code>h2{
  text-align: center;
}
.box{
  width: 500px;
  height: 250px;
  border: 1px solid #f00;
  margin: auto;
  display: flex;
}
.content{
  width: 400px;
  background: #ccc;
  margin: auto;
}
</code></pre>
<h2 id="10-flex-align-self">10、Flex + align-self</h2>
<blockquote>
<p>适用情景：多行文字的垂直居中技巧</p>
</blockquote>
<p>align-self 应该大家都不陌生，基本上就是对flex次轴cross axis 的个别对齐方式只要对单一子层元素设定align-self:center就能达成垂直居中的目的了。</p>
<pre><code>&lt;h2&gt;10.Flex + align-self&lt;/h2&gt;
&lt;div class=&quot;box box10&quot;&gt;
  &lt;div class=&quot;content&quot;&gt;
    立马来看Amos实际完成的    &lt;a href=&quot;http://csscoke.com/2015/07/31/nth-child_rwd_album/&quot;&gt;
      CSS3精美相册效果    &lt;/a&gt;
    效果吧！別忘了拖拉一下窗口看看 RWD 效果喔！  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code>h2{
  text-align: center;
}
.box{
  width: 500px;
  height: 250px;
  border: 1px solid #f00;
  margin: auto;
  display: flex;
  justify-content: center;
}
.content{
  width: 400px;
  background: #ccc;
  align-self: center
}
</code></pre>
<h2 id="11-flex-align-content">11、Flex + align-content</h2>
<blockquote>
<p>适用情景：多行文字的垂直居中技巧</p>
</blockquote>
<p>在正常的状况下，align-content 仅能对次轴多行flex item做居中，但是当我今天子层元素不确定有多少个时，且有时可能会有单个的情况出现时，此技巧就能用到了（当然你也能有其他解法），既然是多行子元素才能用，那我们就为单个子组件多加两个兄弟吧，使用:before以及:after 来让子元素增加到多个，这样就能使用flex的align-content属性来居中</p>
<pre><code>&lt;h2&gt;11.Flex + align-content&lt;/h2&gt;
&lt;div class=&quot;box box11&quot;&gt;
  &lt;div class=&quot;content&quot;&gt;
    立马来看Amos实际完成的    &lt;a href=&quot;http://csscoke.com/2015/07/31/nth-child_rwd_album/&quot;&gt;
      CSS3精美相册效果    &lt;/a&gt;
    效果吧！別忘了拖拉一下窗口看看 RWD 效果喔！  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code>h2{
  text-align: center;
}
.box{
  width: 500px;
  height: 250px;
  border: 1px solid #f00;
  margin: auto;
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  align-content: center;
}
.content{
  width: 400px;
  background: #ccc;
}
.box11:before,
.box11:after{
  content: '';
  display: block;
  width:100%;
}
</code></pre>
<h2 id="12-grid-template">12、Grid + template</h2>
<blockquote>
<p>适用情景：多行文字的垂直居中技巧</p>
</blockquote>
<p>CSS Grid最令人惊讶的就是这个template的功能了，简直就是把块元素当画布在使用，我们仅需要把模板设置成三列，就能搞定垂直居中了</p>
<pre><code>&lt;h2&gt;12.Grid + template&lt;/h2&gt;
&lt;div class=&quot;box box12&quot;&gt;
  &lt;div class=&quot;content&quot;&gt;
    立马来看Amos实际完成的    &lt;a href=&quot;http://csscoke.com/2015/07/31/nth-child_rwd_album/&quot;&gt;
      CSS3精美相册效果    &lt;/a&gt;
    效果吧！別忘了拖拉一下窗口看看 RWD 效果喔！  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code>h2{
  text-align: center;
}
.box{
  width: 500px;
  height: 250px;
  border: 1px solid #f00;
  margin: auto;
  display: grid;
  grid-template-rows: 1fr auto 1fr;
  grid-template-columns: 1fr auto 1fr;
  grid-template-areas: 
    '. . .'
    '. amos .'
    '. . .';
}
.content{
  width: 400px;
  background: #ccc;
  grid-area: amos;
}
</code></pre>
<h2 id="13-grid-align-items">13、Grid + align-items</h2>
<blockquote>
<p>适用情景：多行文字的垂直居中技巧</p>
</blockquote>
<p>align-items不仅是Flex可用，连CSS Grid也拥有此属性可使用，但在Flex中align-items是针对次轴cross axis作对齐，而在CSS Grid中则是针对Y轴做对齐，你可以把它想象成是表格中储存单元格的vertical-align属性看待，就可以很好理解了</p>
<pre><code>&lt;h2&gt;13.Grid + align-items&lt;/h2&gt;
&lt;div class=&quot;box box13&quot;&gt;
  &lt;div class=&quot;content&quot;&gt;
    立马来看Amos实际完成的    &lt;a href=&quot;http://csscoke.com/2015/07/31/nth-child_rwd_album/&quot;&gt;
      CSS3精美相册效果    &lt;/a&gt;
    效果吧！別忘了拖拉一下窗口看看 RWD 效果喔！  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code>h2{
  text-align: center;
}
.box{
  width: 500px;
  height: 250px;
  border: 1px solid #f00;
  margin: auto;
  display: grid;
  justify-content: center;
  align-items: center; 
}
.content{
  width: 400px;
  background: #ccc;
}
</code></pre>
<h2 id="14-grid-align-content">14、Grid + align-content</h2>
<blockquote>
<p>适用情景：杜航文字的垂直居中技巧</p>
</blockquote>
<p>CSS Grid的align-content跟Flex的align-content有点差异，CSS Grid对于空间的解释会跟Flex有一些些的落差，所以导致align-content在Flex中仅能针对多行元素起作用，但在Grid中就没这个问题，所以我们可以很开心的使用align-content来对子元素做垂直居中，丝毫不费力气</p>
<pre><code>&lt;h2&gt;14.Grid + align-content&lt;/h2&gt;
&lt;div class=&quot;box box14&quot;&gt;
  &lt;div class=&quot;content&quot;&gt;
    立马来看Amos实际完成的    &lt;a href=&quot;http://csscoke.com/2015/07/31/nth-child_rwd_album/&quot;&gt;
      CSS3精美相册效果    &lt;/a&gt;
    效果吧！別忘了拖拉一下窗口看看 RWD 效果喔！  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code>h2{
  text-align: center;
}
.box{
  width: 500px;
  height: 250px;
  border: 1px solid #f00;
  margin: auto;
  display: grid;
  justify-content: center;
  align-content: center; 
}
.content{
  width: 400px;
  background: #ccc;
}
</code></pre>
<h2 id="15-grid-align-self">15、Grid + align-self</h2>
<blockquote>
<p>适用情景：多行文字的垂直居中技巧</p>
</blockquote>
<p>align-self 应该大家都不陌生，基本上就是对grid Y轴的个别对齐方式，只要对单一子层元素设置为align-self:center就能达成垂直居中的目的了</p>
<pre><code>&lt;h2&gt;15.Grid + align-self&lt;/h2&gt;
&lt;div class=&quot;box box15&quot;&gt;
  &lt;div class=&quot;content&quot;&gt;
    立马来看Amos实际完成的    &lt;a href=&quot;http://csscoke.com/2015/07/31/nth-child_rwd_album/&quot;&gt;
      CSS3精美相册效果    &lt;/a&gt;
    效果吧！別忘了拖拉一下窗口看看 RWD 效果喔！  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code>h2{
  text-align: center;
}
.box{
  width: 500px;
  height: 250px;
  border: 1px solid #f00;
  margin: auto;
  display: grid;
  justify-content: center;
}
.content{
  width: 400px;
  background: #ccc;
  align-self: center;
}
</code></pre>
<h2 id="16-grid-place-items">16、Grid + place-items</h2>
<blockquote>
<p>适用情景：多行文字的垂直居中技巧</p>
</blockquote>
<p>place-items这属性不知道有多少人用过，此属性是align-items与justify-items的缩写，简单的说就是水平与垂直的对齐方式，想当然的，设定center就能居中</p>
<pre><code>&lt;h2&gt;16.Grid + place-items&lt;/h2&gt;
&lt;div class=&quot;box box16&quot;&gt;
  &lt;div class=&quot;content&quot;&gt;
    立马来看Amos实际完成的    &lt;a href=&quot;http://csscoke.com/2015/07/31/nth-child_rwd_album/&quot;&gt;
      CSS3精美相册效果    &lt;/a&gt;
    效果吧！別忘了拖拉一下窗口看看 RWD 效果喔！  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code>h2{
  text-align: center;
}
.box{
  width: 500px;
  height: 250px;
  border: 1px solid #f00;
  margin: auto;
  display: grid;
  height: 150px;
  margin: 0 auto;
  place-items: center;
}
.content{
  width: 400px;
  background: #ccc;
}
</code></pre>
<h2 id="17-grid-place-content">17、Grid + place-content</h2>
<blockquote>
<p>适用情景：多行文字的垂直居中技巧</p>
</blockquote>
<p>place-content这属性有多少人用过，此属性是align-content与justify-content的缩写，简单的说就是水平与垂直的对齐方式，想当然的，设置center就能居中了</p>
<pre><code>&lt;h2&gt;17.Grid + place-content&lt;/h2&gt;
&lt;div class=&quot;box box17&quot;&gt;
  &lt;div class=&quot;content&quot;&gt;
    立马来看Amos实际完成的    &lt;a href=&quot;http://csscoke.com/2015/07/31/nth-child_rwd_album/&quot;&gt;
      CSS3精美相册效果    &lt;/a&gt;
    效果吧！別忘了拖拉一下窗口看看 RWD 效果喔！  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code>h2{
  text-align: center;
}
.box{
  width: 500px;
  height: 250px;
  border: 1px solid #f00;
  margin: auto;
  display: grid;
  height: 150px;
  margin: 0 auto;
  place-content: center;
}
.content{
  width: 400px;
  background: #ccc;
}
</code></pre>
<h2 id="18-grid-margin">18、Grid + margin</h2>
<blockquote>
<p>适用情景：多行文字的垂直居中技巧</p>
</blockquote>
<p>继续用Grid来居中，由于Grid元素对空间解读的特殊性，我们只要在父层元素设定display:grid，接着在需要垂直居中的元素上设置margin:auto即可自动居中。怎么这描述似曾相识。</p>
<pre><code>&lt;h2&gt;18.Grid + margin&lt;/h2&gt;
&lt;div class=&quot;box box18&quot;&gt;
  &lt;div class=&quot;content&quot;&gt;
    立马来看Amos实际完成的    &lt;a href=&quot;http://csscoke.com/2015/07/31/nth-child_rwd_album/&quot;&gt;
      CSS3精美相册效果    &lt;/a&gt;
    效果吧！別忘了拖拉一下窗口看看 RWD 效果喔！  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code>h2{
  text-align: center;
}
.box{
  width: 500px;
  height: 250px;
  border: 1px solid #f00;
  margin: auto;
  display: grid;
}
.content{
  width: 400px;
  background: #ccc;
  margin:auto;
}
</code></pre>
<h2 id="19-displaytable-cell">19、Display：table-cell</h2>
<blockquote>
<p>适用情景：多行文字的垂直居中技巧</p>
</blockquote>
<p>这一招我想有点年纪的开发者应该都有看过，当然像我这么嫩的开发者当然是第一次看到啦，这一招的原理在于使用 CSS display属性将div设置成表格的单元格，这样就能利用支持存储单元格对齐的vertical-align属性来将信息垂直居中</p>
<pre><code>&lt;h2&gt;19.display: table-cell&lt;/h2&gt;
&lt;div class=&quot;box box19&quot;&gt;
  &lt;div class=&quot;content&quot;&gt;
    立马来看Amos实际完成的    &lt;a href=&quot;http://csscoke.com/2015/07/31/nth-child_rwd_album/&quot;&gt;
      CSS3精美相册效果    &lt;/a&gt;
    效果吧！別忘了拖拉一下窗口看看 RWD 效果喔！  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code>h2{
  text-align: center;
}
.box{
  width: 500px;
  height: 250px;
  border: 1px solid #f00;
  margin: auto;
    text-align: center;
    display: table-cell;
  vertical-align: middle;
}
.content{
  width: 400px;
  background: #ccc;
  margin: auto;
}
</code></pre>
<h2 id="20-calc">20、calc</h2>
<blockquote>
<p>适用情景：多行文字的垂直居中技巧</p>
</blockquote>
<p>Calc是计算机英文单词calculator的缩写，这个由微软提出的css 方法，真的是网页开发者的一个福音。我们竟然可以在网页中直接做计算，这真是太猛了，从此我们再也不用在那边绞尽脑汁的数学计算了，或是想办法用js来动态计算，我们可以很轻松的利用calc()这个方法，来将百分比及时且动态的计算出实际要的是什么高度，真可谓是划时代的一个方法啊，但这个方法需要注意的是大量使用的话，网页性能会是比较差的，所以请谨慎使用。</p>
<pre><code>&lt;h2&gt;20.calc&lt;/h2&gt;
&lt;div class=&quot;box box20&quot;&gt;
  &lt;div class=&quot;content&quot;&gt;
    立马来看Amos实际完成的    &lt;a href=&quot;http://csscoke.com/2015/07/31/nth-child_rwd_album/&quot;&gt;
      CSS3精美相册效果    &lt;/a&gt;
    效果吧！別忘了拖拉一下窗口看看 RWD 效果喔！  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code>h2{
  text-align: center;
}
.box{
  width: 500px;
  height: 250px;
  border: 1px solid #f00;
  margin: auto;
}
.content{
  width: 400px;
  background: #ccc;
  position: relative;
  top:calc((100% - 70px) / 2);
  margin:auto;
  height: 70px;
}
</code></pre>
<h2 id="21-relative-translatey">21、Relative + translateY</h2>
<blockquote>
<p>适用情景：多行文字的垂直居中技巧</p>
</blockquote>
<p>这个技巧是利用了top:50%的招式，让你的元素上方能产生固定百分比的距离，接着让要居中的元素本身使用tanslateY的百分比来达成垂直居中的需求，translate是一个很棒的属性，由于translate的百分比单位是利用元素自身的尺寸作为100%，这样让我们要利用元素自身宽高做事变得方便很多。</p>
<pre><code>&lt;h2&gt;21.relative + translateY(-50%)&lt;/h2&gt;
&lt;div class=&quot;box box21&quot;&gt;
  &lt;div class=&quot;content&quot;&gt;
    立马来看Amos实际完成的    &lt;a href=&quot;http://csscoke.com/2015/07/31/nth-child_rwd_album/&quot;&gt;
      CSS3精美相册效果    &lt;/a&gt;
    效果吧！別忘了拖拉一下窗口看看 RWD 效果喔！  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code>h2{
  text-align: center;
}
.box{
  width: 500px;
  height: 250px;
  border: 1px solid #f00;
  margin: auto;
}
.content{
  width: 400px;
  background: #ccc;
  position: relative;
  top: 50%;
  transform: translateY(-50%);
  margin: auto;
}
</code></pre>
<h2 id="22-padding">22、padding</h2>
<blockquote>
<p>适用情景：多行文字的垂直居中技巧</p>
</blockquote>
<p>什么！这也算垂直居中技巧，连我奶奶都知道这方式吧</p>
<p>对的，这的确也算是一种垂直居中的方式，不可讳言的这方式真的是简单过头了，以至于有些开发者认为这种方式都不能算是一种垂直居中的技巧，但同样的你无法反驳的是，我的数据的确垂直居中啦，好啦，就当我硬凹吧，你说的对，好吧</p>
<pre><code>&lt;h2&gt;22.padding&lt;/h2&gt;
&lt;div class=&quot;box box22&quot;&gt;
  &lt;div class=&quot;content&quot;&gt;
    立马来看Amos实际完成的    &lt;a href=&quot;http://csscoke.com/2015/07/31/nth-child_rwd_album/&quot;&gt;
      CSS3精美相册效果    &lt;/a&gt;
    效果吧！別忘了拖拉一下窗口看看 RWD 效果喔！  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code>h2{
  text-align: center;
}
.box{
  width: 500px;
  border: 1px solid #f00;
  margin: auto;
  height: auto;
  padding: 50px 0;
}
.content{
  width: 400px;
  background: #ccc;
  margin: auto;
}
</code></pre>
<h2 id="23-write-mode">23、Write-mode</h2>
<blockquote>
<p>适用情景：多行文字的垂直剧种技巧</p>
</blockquote>
<p>这个方式应该是比较少见到的有人使用的了，这个想法是被老友Paul所激发的，write-mode这个css属性的功能基本上跟垂直居中是八竿子打不着，它的用途是改变文字书写的方向从横变竖，且支持度从很早期的IE5就有支持了，但当时Amos很少使用，一来是网页多是横书较多，另外当时除了IE浏览器意外，其他浏览器的支持度都不是很好，也就很少使用了。</p>
<p>使用write-mode将一整个文字容器变成直书，接着将此容器利用text-align:center来达到垂直居中的目的，白话一点的解说就是，你把原本横排的文字变成竖排，所以原本横排用到的水平对齐方式，就变成了控制直排的中间了，原理就是这么简单。但要特别注意的是浏览器对此语法的支持度来说，需要拆开写法才行，不然某些浏览器的语法不同，可能会让你的网页在某些浏览器上看起来无效，这会是最需要注意到的</p>
<pre><code>&lt;h2&gt;23.writing-mode&lt;/h2&gt;立马来看Amos实际完成的
&lt;div class=&quot;box box23&quot;&gt;
  &lt;div class=&quot;content&quot;&gt;
    &lt;div class=&quot;txt&quot;&gt;
      立马来看Amos实际完成的      &lt;a href=&quot;http://csscoke.com/2015/07/31/nth-child_rwd_album/&quot;&gt;
        CSS3精美相册效果      &lt;/a&gt;
      效果吧！別忘了拖拉一下窗口看看 RWD 效果喔！
      這個置中的想法來自於 Paul 
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code>h2{
  text-align: center;
}
.box{
  width: 500px;
  height: 250px;
  border: 1px solid #f00;
  margin: auto;
  writing-mode: tb-lr; /* for ie11 */
  writing-mode: vertical-lr;
  text-align: center;
  margin:0 auto;
}
.content{
  width: 400px;
  background: #ccc;
  display: inline-block; /* for ie &amp; edge */
  width: 100%;
  writing-mode: lr-tb;
  margin: auto; 
  text-align: left;
}
.box .txt{
  width: 80%;
  margin: auto;
}
</code></pre>
<p><em>关于本文<br>
作者：@Amos<br>
原文：<br>
<a href="http://csscoke.com/2018/08/21/css-vertical-align/">原文地址</a></em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue基于hls.js的流媒体直播基本用法]]></title>
        <id>https://duanjiuzhou.github.io/mengff.github.io/post/vue-ji-yu-hlsjs-de-liu-mei-ti-zhi-bo-ji-ben-yong-fa/</id>
        <link href="https://duanjiuzhou.github.io/mengff.github.io/post/vue-ji-yu-hlsjs-de-liu-mei-ti-zhi-bo-ji-ben-yong-fa/">
        </link>
        <updated>2020-08-04T08:29:50.000Z</updated>
        <summary type="html"><![CDATA[<p>hls.js是一个实现HTTP Live Streaming客户端的JavaScript库。本篇主要介绍该插件的在vue中基本使用方法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>hls.js是一个实现HTTP Live Streaming客户端的JavaScript库。本篇主要介绍该插件的在vue中基本使用方法。</p>
<!-- more -->
<h2 id="hlsjs-介绍">hls.js 介绍</h2>
<p><a href="https://github.com/video-dev/hls.js">hls.js</a>是一个实现HTTP Live Streaming客户端的JavaScript库。它依靠HTML5视频和MediaSource扩展进行播放。</p>
<p>它的工作原理是将MPEG-2传输流和AAC / MP3流转换为ISO BMFF（MP4）片段。如果在浏览器中可用，则可以使用Web Worker异步执行此传输。<code>hls.js</code>也支持<code>HLS+fmp4</code>，正如在<code>WWDC2016</code>期间宣布的那样<code>hls.js</code>不需要任何播放器，它直接在标准的HTML <code>&lt;video&gt;</code>元素之上工作。<code>hls.js</code> 使用<code>ECMAScript6</code>编写，使用<code>Babel</code>在<code>ECMAScript5</code>中编译。</p>
<h2 id="基本入门">基本入门</h2>
<pre><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/hls.js@latest&quot;&gt;&lt;/script&gt;
&lt;!-- Or if you want a more recent canary version --&gt;
&lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/hls.js@canary&quot;&gt;&lt;/script&gt; --&gt;
&lt;video id=&quot;video&quot;&gt;&lt;/video&gt;
&lt;script&gt;
  var video = document.getElementById('video');
  if(Hls.isSupported()) {
    var hls = new Hls();
    hls.loadSource('https://video-dev.github.io/streams/x36xhzz/x36xhzz.m3u8');
    hls.attachMedia(video);
    hls.on(Hls.Events.MANIFEST_PARSED,function() {
      video.play();
  });
 }
 // hls.js is not supported on platforms that do not have Media Source Extensions (MSE) enabled.
 // When the browser has built-in HLS support (check using `canPlayType`), we can provide an HLS manifest (i.e. .m3u8 URL) directly to the video element throught the `src` property.
 // This is using the built-in support of the plain video element, without using hls.js.
 // Note: it would be more normal to wait on the 'canplay' event below however on Safari (where you are most likely to find built-in HLS support) the video.src URL must be on the user-driven
 // white-list before a 'canplay' event will be emitted; the last video event that can be reliably listened-for when the URL is not on the white-list is 'loadedmetadata'.
  else if (video.canPlayType('application/vnd.apple.mpegurl')) {
    video.src = 'https://video-dev.github.io/streams/x36xhzz/x36xhzz.m3u8';
    video.addEventListener('loadedmetadata',function() {
      video.play();
    });
  }
&lt;/script&gt;
</code></pre>
<h2 id="安装">安装</h2>
<p>要么直接包含dist / hls.js或dist / hls.min.js</p>
<p>或者输入</p>
<pre><code>npm install --save hls.js
</code></pre>
<p>可以选择有一个声明文件可用于帮助完成代码并在hls.js api的IDE中提示</p>
<pre><code>npm install --save-dev @ types / hls.js
</code></pre>
<p>npm方式时，在.vue组件中引入</p>
<pre><code> var Hls = require('hls.js/dist/hls');
</code></pre>
<p><strong>注意：</strong></p>
<p>在vue组件中声明hls实例<code>new Hls()</code>,一定要在组件销毁前注销hls实例，否则会造成内存泄漏（都是坑出来的o(╥﹏╥)o）</p>
<pre><code>beforeDestroy() {
    // 注销hls 实例
    this.hls.destroy();
},
</code></pre>
<h2 id="基本api用法">基本api用法</h2>
<blockquote>
<p>loadSource(url)</p>
</blockquote>
<p>用于加载.m3u8文件路径 {string} url；</p>
<blockquote>
<p>attachMedia()</p>
</blockquote>
<p>挂载media元素；</p>
<blockquote>
<p>destroy()</p>
</blockquote>
<p>注销实例;</p>
<blockquote>
<p>detachMedia()</p>
</blockquote>
<p>Detach from the media;</p>
<blockquote>
<p>startLoad()</p>
</blockquote>
<p>Start loading data from the stream source.Depending on default config, client starts loading automatically when a source is set.</p>
<blockquote>
<p>stopLoad()</p>
</blockquote>
<p>Stop loading of any stream data.</p>
<blockquote>
<p>swapAudioCodec()</p>
</blockquote>
<p>Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)</p>
<blockquote>
<p>recoverMediaError()</p>
</blockquote>
<p>When the media-element fails, this allows to detach and then re-attach it as one call (convenience method).</p>
<h2 id="常规事件">常规事件</h2>
<blockquote>
<p>ERROR</p>
</blockquote>
<p>含义：hls的错误事件。<br>
使用方法：</p>
<pre><code>this.hls = new Hls();
this.hls.on(Hls.Events.ERROR, (data) =&gt; {
    do something~~        
});
</code></pre>
<blockquote>
<p>其它事件介绍</p>
</blockquote>
<pre><code>  // fired before MediaSource is attaching to media element - data: { media }
  MEDIA_ATTACHING: 'hlsMediaAttaching',
  // fired when MediaSource has been succesfully attached to media element - data: { }
  MEDIA_ATTACHED: 'hlsMediaAttached',
  // fired before detaching MediaSource from media element - data: { }
  MEDIA_DETACHING: 'hlsMediaDetaching',
  // fired when MediaSource has been detached from media element - data: { }
  MEDIA_DETACHED: 'hlsMediaDetached',
  // fired when we buffer is going to be reset - data: { }
  BUFFER_RESET: 'hlsBufferReset',
  // fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}
  BUFFER_CODECS: 'hlsBufferCodecs',
  // fired when sourcebuffers have been created - data: { tracks : tracks }
  BUFFER_CREATED: 'hlsBufferCreated',
  // fired when we append a segment to the buffer - data: { segment: segment object }
  BUFFER_APPENDING: 'hlsBufferAppending',
  // fired when we are done with appending a media segment to the buffer - data : { parent : segment parent that triggered BUFFER_APPENDING, pending : nb of segments waiting for appending for this segment parent}
  BUFFER_APPENDED: 'hlsBufferAppended',
  // fired when the stream is finished and we want to notify the media buffer that there will be no more data - data: { }
  BUFFER_EOS: 'hlsBufferEos',
  // fired when the media buffer should be flushed - data { startOffset, endOffset }
  BUFFER_FLUSHING: 'hlsBufferFlushing',
  // fired when the media buffer has been flushed - data: { }
  BUFFER_FLUSHED: 'hlsBufferFlushed',
  // fired to signal that a manifest loading starts - data: { url : manifestURL}
  MANIFEST_LOADING: 'hlsManifestLoading',
  // fired after manifest has been loaded - data: { levels : [available quality levels], audioTracks : [ available audio tracks], url : manifestURL, stats : { trequest, tfirst, tload, mtime}}
  MANIFEST_LOADED: 'hlsManifestLoaded',
  // fired after manifest has been parsed - data: { levels : [available quality levels], firstLevel : index of first quality level appearing in Manifest}
  MANIFEST_PARSED: 'hlsManifestParsed',
  // fired when a level switch is requested - data: { level : id of new level }
  LEVEL_SWITCHING: 'hlsLevelSwitching',
  // fired when a level switch is effective - data: { level : id of new level }
  LEVEL_SWITCHED: 'hlsLevelSwitched',
  // fired when a level playlist loading starts - data: { url : level URL, level : id of level being loaded}
  LEVEL_LOADING: 'hlsLevelLoading',
  // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : { trequest, tfirst, tload, mtime} }
  LEVEL_LOADED: 'hlsLevelLoaded',
  // fired when a level's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, level : id of updated level }
  LEVEL_UPDATED: 'hlsLevelUpdated',
  // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }
  LEVEL_PTS_UPDATED: 'hlsLevelPtsUpdated',
  // fired to notify that audio track lists has been updated - data: { audioTracks : audioTracks }
  AUDIO_TRACKS_UPDATED: 'hlsAudioTracksUpdated',
  // fired when an audio track switching is requested - data: { id : audio track id }
  AUDIO_TRACK_SWITCHING: 'hlsAudioTrackSwitching',
  // fired when an audio track switch actually occurs - data: { id : audio track id }
  AUDIO_TRACK_SWITCHED: 'hlsAudioTrackSwitched',
  // fired when an audio track loading starts - data: { url : audio track URL, id : audio track id }
  AUDIO_TRACK_LOADING: 'hlsAudioTrackLoading',
  // fired when an audio track loading finishes - data: { details : levelDetails object, id : audio track id, stats : { trequest, tfirst, tload, mtime } }
  AUDIO_TRACK_LOADED: 'hlsAudioTrackLoaded',
  // fired to notify that subtitle track lists has been updated - data: { subtitleTracks : subtitleTracks }
  SUBTITLE_TRACKS_UPDATED: 'hlsSubtitleTracksUpdated',
  // fired when an subtitle track switch occurs - data: { id : subtitle track id }
  SUBTITLE_TRACK_SWITCH: 'hlsSubtitleTrackSwitch',
  // fired when a subtitle track loading starts - data: { url : subtitle track URL, id : subtitle track id }
  SUBTITLE_TRACK_LOADING: 'hlsSubtitleTrackLoading',
  // fired when a subtitle track loading finishes - data: { details : levelDetails object, id : subtitle track id, stats : { trequest, tfirst, tload, mtime } }
  SUBTITLE_TRACK_LOADED: 'hlsSubtitleTrackLoaded',
  // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag }
  SUBTITLE_FRAG_PROCESSED: 'hlsSubtitleFragProcessed',
  // fired when the first timestamp is found - data: { id : demuxer id, initPTS: initPTS, frag : fragment object }
  INIT_PTS_FOUND: 'hlsInitPtsFound',
  // fired when a fragment loading starts - data: { frag : fragment object }
  FRAG_LOADING: 'hlsFragLoading',
  // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded } }
  FRAG_LOAD_PROGRESS: 'hlsFragLoadProgress',
  // Identifier for fragment load aborting for emergency switch down - data: { frag : fragment object }
  FRAG_LOAD_EMERGENCY_ABORTED: 'hlsFragLoadEmergencyAborted',
  // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : { trequest, tfirst, tload, length } }
  FRAG_LOADED: 'hlsFragLoaded',
  // fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, payload : fragment payload, stats : { tstart, tdecrypt } }
  FRAG_DECRYPTED: 'hlsFragDecrypted',
  // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment }
  FRAG_PARSING_INIT_SEGMENT: 'hlsFragParsingInitSegment',
  // fired when parsing sei text is completed - data: { id : demuxer id, frag: fragment object, samples : [ sei samples pes ] }
  FRAG_PARSING_USERDATA: 'hlsFragParsingUserdata',
  // fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }
  FRAG_PARSING_METADATA: 'hlsFragParsingMetadata',
  // fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}
  FRAG_PARSING_DATA: 'hlsFragParsingData',
  // fired when fragment parsing is completed - data: { id : demuxer id, frag: fragment object }
  FRAG_PARSED: 'hlsFragParsed',
  // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id, frag : fragment object, stats : { trequest, tfirst, tload, tparsed, tbuffered, length, bwEstimate } }
  FRAG_BUFFERED: 'hlsFragBuffered',
  // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }
  FRAG_CHANGED: 'hlsFragChanged',
  // Identifier for a FPS drop event - data: { curentDropped, currentDecoded, totalDroppedFrames }
  FPS_DROP: 'hlsFpsDrop',
  // triggered when FPS drop triggers auto level capping - data: { level, droppedlevel }
  FPS_DROP_LEVEL_CAPPING: 'hlsFpsDropLevelCapping',
  // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data }
  ERROR: 'hlsError',
  // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example - data: { }
  DESTROYING: 'hlsDestroying',
  // fired when a decrypt key loading starts - data: { frag : fragment object }
  KEY_LOADING: 'hlsKeyLoading',
  // fired when a decrypt key loading is completed - data: { frag : fragment object, payload : key payload, stats : { trequest, tfirst, tload, length } }
  KEY_LOADED: 'hlsKeyLoaded',
  // fired upon stream controller state transitions - data: { previousState, nextState }
  STREAM_STATE_TRANSITION: 'hlsStreamStateTransition'
</code></pre>
<h2 id="兼容性">兼容性</h2>
<p>截至2018/7，它支持：</p>
<ul>
<li>Chrome for Android 34+</li>
<li>Chrome for Desktop 34+</li>
<li>适用于Android的Firefox 41+</li>
<li>Firefox for Desktop 42+</li>
<li>IE11 + for Windows 8.1+</li>
<li>Edge for Windows 10+</li>
<li>Opera for Desktop</li>
<li>Vivaldi for Desktop</li>
<li>Safari for Mac 8+（测试版）</li>
</ul>
<p>请注意：iOS Safari“Mobile”不支持MediaSource API。然而，Safari浏览器通过纯视频“标签”源URL支持内置的HLS支持。请参阅上面的示例（入门指南）运行适当的功能检测并选择使用Hls.js或本机内置的HLS支持。</p>
<p>当平台既没有MediaSource也没有本地HLS支持时，您将无法播放HLS。</p>
<h2 id="事件流">事件流</h2>
<p>由于内部通信都是基于 EventEmitter 来实现，透过事件流，你可以了解到代码运行的整体流程。</p>
<p>hls 整体流程如下：</p>
<figure data-type="image" tabindex="1"><img src="https://img.colabug.com/2017/11/382f3e53f4e662010efee1fd000feca8.png" alt="image" loading="lazy"></figure>
<p>hls实际会先通过 ajax（loader 是可以完成自定义的） 请求 m3u8文件，然后会读取到文件的分片列表，以及视频的编码格式，时长等。随后会按照顺序(非 seek )去对分片进行请求，这些也是通过 ajax 请求二进制的文件，然后借助 Media Source Extensions 将 buffer 内容进行合流，然后组成一个可播的媒体资源文件。</p>
<p>由于内部通过自定事件进行数据传递和流程控制，参考下面的图：</p>
<figure data-type="image" tabindex="2"><img src="https://img.colabug.com/2017/11/39ccf4fdcc416d91a5f1811b4561927d.png" alt="image" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mysql操作 (五) 之SQL 高级数据操作]]></title>
        <id>https://duanjiuzhou.github.io/mengff.github.io/post/mysql-cao-zuo-wu-zhi-sql-gao-ji-shu-ju-cao-zuo/</id>
        <link href="https://duanjiuzhou.github.io/mengff.github.io/post/mysql-cao-zuo-wu-zhi-sql-gao-ji-shu-ju-cao-zuo/">
        </link>
        <updated>2020-08-04T08:29:20.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇主要总结下mysql中的主键冲突、蠕虫复制、限制数量、查询条件判断、字段别名等使用方法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇主要总结下mysql中的主键冲突、蠕虫复制、限制数量、查询条件判断、字段别名等使用方法。</p>
<!-- more -->
<h1 id="数据高级操作">数据高级操作</h1>
<p>数据操作：增删改查</p>
<h2 id="1-新增数据">1、新增数据</h2>
<p>基本语法：</p>
<pre><code>insert into 表名 [(字段列表)] values(值列表);
</code></pre>
<p>在数据插入的时候，假设主键对应的值已经存在：插入一定会失败。</p>
<blockquote>
<p>主键冲突</p>
</blockquote>
<p>当主键存在冲突的时候(Duplicate key)，可以选择性的进行处理，更新和替换。</p>
<ul>
<li>
<p>主键冲突：更新操作</p>
<pre><code>insert into 表名 [(字段列表:包含主键] values(值列表) on duplicate key update 字段 = 新值;
</code></pre>
<p>例：</p>
<pre><code>-- 插入数据  第一个参数为主键
insert into my_calss values(&quot;php1&quot;,&quot;1&quot;);  -- 插入成功
insert into my_calss values(&quot;php1&quot;,&quot;2&quot;);  -- 插入失败 主键冲突

-- 主键冲突：更新
insert into my_class values(&quot;php1&quot;,&quot;2&quot;)
-- 冲突处理
on duplicate key update
-- 更新数据
room = '2';
</code></pre>
</li>
<li>
<p>主键冲突：替换</p>
<pre><code>replace into 表名 [(字段列表：包含主键)] values(值列表);
</code></pre>
<p>例：</p>
<pre><code>-- 主键冲突：替换
replace into my_calss values(&quot;php1&quot;,&quot;2&quot;);
</code></pre>
<p><strong>注意：</strong> 没有冲突则插入数据。有冲突替换。</p>
</li>
</ul>
<blockquote>
<p>蠕虫复制</p>
</blockquote>
<p>蠕虫复制：从已有的数据中去获取数据，然后将数据又进行新增操作：数据成倍的增加。</p>
<p>表创建高级操作：从已有表创建新表（复制表结构）</p>
<pre><code>create table 表名 like 数据库.表名;
</code></pre>
<pre><code>-- 复制创建表: 表结构复制，数据不复制
create table my_copy like mg_gbk;
</code></pre>
<p>蠕虫复制：先查出数据，然后将查出的数据新增一遍</p>
<pre><code>insert into 表名[(字段列表)] select 字段列表/* from 数据表名;
</code></pre>
<p>例：</p>
<pre><code>-- 蠕虫复制
insert into my_copy select * from my_collate_bin;  -- 复制别的表
insert into my_copy select * from my_copy;         -- 复制自己的表
</code></pre>
<p>蠕虫复制的意义：</p>
<ol>
<li>从已有表拷贝数据到新表中</li>
<li>可以迅速的让表中数据膨胀到一定的数量级，测试表的压力以及效率。</li>
</ol>
<h2 id="2-更新数据限制数量">2、更新数据(限制数量)</h2>
<p>基本语法：</p>
<pre><code>update 表名 set 字段 = 值 [where 条件];
</code></pre>
<p>高级新增语法：</p>
<pre><code>update 表名 set 字段 = 值 [where 条件][limit 更新数量];
</code></pre>
<p>例：更新部分数据</p>
<pre><code>--更新部分a变成c
update my_copy set name = 'c' where name = 'a' limit 3;
</code></pre>
<h2 id="3-删除数据">3、删除数据</h2>
<p>与更新类似，可以通过limit来限制数量。</p>
<pre><code>delete from 表名 [where 条件][limit 数量];
</code></pre>
<p>例：</p>
<pre><code>-- 删除数据：限制记录数为10
delete from my_copy where name = 'b' limit 10;
</code></pre>
<p>删除：如果表中存在主键自增长，那么当删除后，自增长不会还原。</p>
<p>思路：数据的删除是不会改变表结构，只能删除表后重建表。注意：表数据会被清空。只有表结构。</p>
<pre><code>truncate 表名;  -- 先删除改变，后新增改变。
</code></pre>
<p>例：</p>
<pre><code>-- 清空表：重置自增长
truncate my_student;
</code></pre>
<h2 id="4-查询数据">4、查询数据</h2>
<p>基本语法：</p>
<pre><code>select 字段列表/* from 表名 [where 条件];
</code></pre>
<p>完整语法：</p>
<pre><code>select [select 选项] 字段列表[字段别名]/* from 数据源 [where 条件子句][group by子句][having子句][order by 子句][limit 子句;
</code></pre>
<ol>
<li>
<p>select 选项<br>
含义: select对查出来的结果的处理方式</p>
<ul>
<li>all：默认的，保留所有的结果。</li>
<li>distinct：去重，查出来的结果，将重复的去除（所有字段都相同） 是对所有的字段进行去除</li>
</ul>
<pre><code>-- select选项  以下这俩表达的意思一样
select * from my_copy;
select all * from my_copy;
</code></pre>
<pre><code>-- 去重
select distinct * from my_copy;
</code></pre>
</li>
<li>
<p>字段别名</p>
<p>含义：当数据进行查询出来的时候，有时候名字并不一定就满足需求(多表查询的时候，会有同名字段) 需要对字段名进行重命名：别名。</p>
<p>基本语法：</p>
<pre><code>字段名 [as] 别名;  -- 加as或者不加as都行。
</code></pre>
<p>例：</p>
<pre><code>-- 字段别名
select
id,
number as 学号,
name as 姓名,
sex 性别 from my_student;
</code></pre>
</li>
<li>
<p>数据源</p>
<p>含义：数据的来源，关系型数据库的来源都是数据表，本质上只要保证数据类似二维表，最终都可以作为数据源。</p>
<p>数据源分为多种：单表数据源，多表数据源，查询语句</p>
<p>单表数据源：</p>
<pre><code>select * from 表名;
</code></pre>
<p>多表数据源：</p>
<pre><code>select * from 表名1,表名2，,...;
</code></pre>
<p>从一张表中取出一条记录，去另外一张表匹配所有记录，而且全部保留（记录数和字段数）将这种结果称为：笛卡尔积(交叉连接)。笛卡尔积没什么用，尽量避免使用。</p>
<p>子查询：数据的来源是一条查询语句(查询语句的结果是二维表)</p>
<pre><code>select * from (select 语句) as 表名;
</code></pre>
<p>例：</p>
<pre><code>-- 子查询
select * from (select * from my_student) as s;
</code></pre>
</li>
<li>
<p>where子句</p>
<p>where子句：用于判断数据，筛选数据。</p>
<p>where子句返回的结果：0或者1,  0代表false, 1代表true;</p>
<pre><code>select * from my_student where 1; -- 表示所有条件都满足，这种表达是为了语句的完整性。
</code></pre>
<p>判断条件：</p>
<ul>
<li>比较运算符：&gt;,&lt;,&gt;=,&lt;=,!=,&lt;&gt;,=,like,between,and,in/ont in</li>
<li>逻辑运算符：&amp;&amp;(and), ||(or), !(not)</li>
</ul>
<p>where原理：where是唯一一个直接从磁盘获取数据的时候就开始判断的条件：从磁盘取出一条记录，开始进行where判断，判断的结果，如果成立就保存到内存，如果失败就直接放弃。</p>
<p>条件查询1：</p>
<p>例：找出学生id为1,3,5的数据</p>
<pre><code>-- 找出学生id为1,3,5的数据， 以下两种语句结果一样
select * from my_student where id = 1 || id = 3 || id = 5; -- 逻辑判断
select * from my_student where id in(1,3,5); -- 落在集合中
</code></pre>
<p>条件查询2：</p>
<p>例：找身高在180到190之间的学生</p>
<pre><code>-- 找身高在180到190之间的学生，以下两种语句结果一样
select * from my_student where height &gt;= 180 and height &lt;= 190;
select * from my_student where height between 180 and 190;
</code></pre>
<p><strong>注意：</strong> between本身是闭区间，between左边的值必须小于等于右边的值</p>
</li>
<li>
<p>group by子句</p>
<p>group by：分组的意思，根据某个字段进行分组（相同的放一组，不同的分到不同的组）。</p>
<pre><code>-- 根据性别分组
select * from my_student group by sex;
</code></pre>
<p>分组的意思：是为了统计数据（按组统计：按分组字段进行数据统计）</p>
<p>SQL提供了一系列的统计函数</p>
<ul>
<li>count()：统计分组后的记录数：每一组有多少记录</li>
<li>max()：统计每组中最大的值</li>
<li>min()：统计最小值</li>
<li>avg()：统计平均值</li>
<li>sum()：统计和</li>
</ul>
<p>例：</p>
<pre><code>-- 分组统计：身高高矮，年龄平均和总年龄
select sex,count(*), max(height),min(height),avg(age),sum(age) from my_student group by sex;
</code></pre>
<p>count函数：里面可以使用两种参数：* 代表统计记录，字段名代表统计对应的字段(NULL不统计)</p>
<p>分组会自动排序：根据分组字段：默认升序</p>
<pre><code>-- asc：升序， desc：降序
group by 字段 [asc|desc]; -- 对分组的结果合并之后的整个结果进行排序。

</code></pre>
<p>例：</p>
<pre><code>select sex,count(*), max(height),min(height),avg(age),sum(age) from my_student group by sex desc;
</code></pre>
<p>多字段分组：先根据一个字段进行分组，然后对分组后的结果再次按照其他字段进行分组。</p>
<p>例：</p>
<pre><code>-- 多字段分组: 先班级，后男女
select c_id,sex,count(*) from my_student group by c_id,sex; -- 多字段排序
</code></pre>
<p>有一个函数：可以对分组的结果中某个字段进行字符串连接(保留该组所有的某个字段)</p>
<pre><code>group_concat(字段);
</code></pre>
<p>例：</p>
<pre><code>-- 多字段分组: 先班级，后男女
select c_id,sex,count(*),group_concat(name) from my_student group by c_id,sex; -- 多字段排序
</code></pre>
<p>回溯统计：with rollup; 任何一个分组后都会有一个小组，最后都需要向上级分组进行汇报统计，根据当前分组的字段。这就是回溯统计。特点：回溯统计的时候会将分组字段置空。</p>
<pre><code>-- 统计
select c_id,count(*) from my_student group by c_id;

-- 回溯统计
select c_id,count(*) from my_student group by c_id with rollop;

-- 多字段分组回溯统计
select c_id,sex,count(*),group_concat(name) from my_student group by c_id,sex; -- 多字段排序
select c_id,sex,count(*),group_concat(name) from my_student group by c_id,sex with rollop; -- 多字段分组回溯统计
</code></pre>
<p>多字段回溯：考虑第一层分组会有一次回溯，第二次分组要看第一次分组的组数，组数是多少，回溯就是多少，然后再加上第一层回溯即可。</p>
</li>
<li>
<p>having子句</p>
</li>
<li>
<p>order by子句</p>
</li>
<li>
<p>limit子句</p>
</li>
</ol>
<p>含义：limit子句是一种限制结果的语句：限制数量</p>
<p>limit有两种使用方式：</p>
<p>方案1：只用来限制长度(数据量)：limit数据量；</p>
<p>例：</p>
<pre><code>--查询学生：前两个
select * from my_student limit 2;
</code></pre>
<p>方案2：限制起始位置，限制数量：limit 起始位置,限制数;</p>
<p>例：</p>
<pre><code>-- 查询学生：前两个
select * from my_student limit 0,2; -- 记录数是从0开始编号
</code></pre>
<p>limit 方案2：主要用来实现数据的分页：为用户节省时间，提高服务器的响应效率，减少资源的浪费。</p>
<p>对于用户来讲：可以点击的分页按钮1,2,3,4</p>
<p>对于服务器来讲，根据用户选择的页码来获取不同的数据：limit offset,length;</p>
<p>length:每页显示的数据量：基本不变。</p>
<p>offset: offset=(页码 - 1) * 每页显示量</p>
<p>分页查询语句及获取总记录数</p>
<pre><code>select SQL_CALC_FOUND_ROWS  * from bloglist order by id limit 2,2;
SELECT FOUND_ROWS();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mysql操作 (四) 之SQL 中文数据问题]]></title>
        <id>https://duanjiuzhou.github.io/mengff.github.io/post/mysql-cao-zuo-si-zhi-sql-zhong-wen-shu-ju-wen-ti/</id>
        <link href="https://duanjiuzhou.github.io/mengff.github.io/post/mysql-cao-zuo-si-zhi-sql-zhong-wen-shu-ju-wen-ti/">
        </link>
        <updated>2020-08-04T08:28:24.000Z</updated>
        <summary type="html"><![CDATA[<p>SQL 里中文数据问题的本质是字符集问题。计算机只能识别二进制，人类更多的是识别符号；需要有一个二进制与字符的对应关系（字符集）...</p>
]]></summary>
        <content type="html"><![CDATA[<p>SQL 里中文数据问题的本质是字符集问题。计算机只能识别二进制，人类更多的是识别符号；需要有一个二进制与字符的对应关系（字符集）...</p>
<!-- more -->
<h2 id="中文数据问题">中文数据问题</h2>
<p>中文数据问题的本质是字符集问题。</p>
<p>计算机只能识别二进制，人类更多的是识别符号；需要有一个二进制与字符的对应关系（字符集）；</p>
<p>客户端向服务器插入中文数据没有成功。</p>
<pre><code>--插入中文数据
insert into my_student values(5,'ddd','张越','猫');  // 报错
</code></pre>
<p>原因：\xD5\xD5\xD4\xBD 代表的是“张越”在当前编码（字符集）下对应的二进制编码转换成的十六进制：两个汉字 =》 四个字节（GBK）</p>
<p>报错：服务器没有识别对应的四个字节：服务器认为数据是UTF8，一个汉字有三个字节；读取三个字节转换成汉字（失败），剩余的再读三个字节（不够）；最终失败。</p>
<p>所有的数据库服务器认为（表现）的一些特性都是通过服务器端的变量来保存；系统先读取自己的变量，看看应该怎么表现。</p>
<p>// 查看服务器到底识别哪些字符集</p>
<pre><code>-- 查看所有字符集
show character set;
</code></pre>
<p>基本上：服务器是万能的，什么字符集都支持。</p>
<p>// 既然服务器识别这么多，总有一种是服务器默认与客户端打交道的字符集</p>
<pre><code>-- 查看服务器默认的对外处理的字符集
show variables like 'character_set%';
</code></pre>
<p>问题根源：客户端数据只能是GBK，而服务器认为是UTF8;矛盾产出。</p>
<p>解决方案：改变服务器，默认的接受字符集为GBK；</p>
<pre><code>-- 修改服务器认为的客户端数据的字符集为GBK
set character_set_client = gbk;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mysql操作 (三) 之SQL 数据操作]]></title>
        <id>https://duanjiuzhou.github.io/mengff.github.io/post/mysql-cao-zuo-san-zhi-sql-shu-ju-cao-zuo/</id>
        <link href="https://duanjiuzhou.github.io/mengff.github.io/post/mysql-cao-zuo-san-zhi-sql-shu-ju-cao-zuo/">
        </link>
        <updated>2020-08-04T08:26:26.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇主要介绍mysql中的数据操作，一些基础的增删改查，常规的使用方法，一起来看吧。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇主要介绍mysql中的数据操作，一些基础的增删改查，常规的使用方法，一起来看吧。</p>
<!-- more -->
<h2 id="sql-数据操作">SQL 数据操作</h2>
<blockquote>
<p>新增数据</p>
</blockquote>
<p>有两种方案</p>
<p><strong>方案1：</strong> 给全表字段插入数据，不需要指定字段列表</p>
<p>要求：要求数据的值出现的顺序必须与表中设计的字段出现的顺序一致，凡事非数值数据，都需要使用引号（建议是单引号）包裹。</p>
<p>基本语法：</p>
<pre><code>insert into 表名 values(值列表)[,值列表]; -- 可以一次性插入多条数据
</code></pre>
<p>例：</p>
<pre><code>-- 插入数据
insert into my_student values(1,'inst111','jim','male'),((2,'inst222','jsse','male');  
</code></pre>
<p><strong>方案2：</strong> 给部分字段插入数据，需要选定字段列表，字段列表出现顺序与字段的顺序无关；但是值列表的顺序必须与选定的字段的顺序一致。</p>
<p>基本语法：</p>
<pre><code>insert into 表名 (字段列表) values(值列表)[,值列表]; 
</code></pre>
<p>例：</p>
<pre><code>-- 插入数据：指定字段列表
insert into my_student (number,sex,name,id) values
('ictast001','male','tom',3),
('ictast002','male','lily',4);
</code></pre>
<blockquote>
<p>查看数据</p>
</blockquote>
<p>基本语法：</p>
<pre><code>select */字段列表 from 表名 [where 条件];
</code></pre>
<p>例：</p>
<pre><code>-- 查看所有数据
select * from my_student;

-- 查看指定字段，指定条件数据
select id,number,sex from my_student where id=1; -- 查看满足id为1的数据
</code></pre>
<blockquote>
<p>更新数据</p>
</blockquote>
<p>基本语法：</p>
<pre><code>update 表名 set 字段 = 值 [where 条件]; -- 建议都有where，要不加更新全部
</code></pre>
<p>例：<br>
本篇主要介绍mysql中的数据操作，一些基础的增删改查，常规的使用方法，一起来看吧。</p>
<!-- more -->
<pre><code>-- 更新数据
update my_student set sex = 'female' where name = 'jim';
</code></pre>
<p>初始<br>
更新不一定会成功，如没有真正要更新的数据。如果该数据的初始值为1，更新该数据还为1，那并没有真正更新该数据。判断数据更新成功，需要看受影响的行数。</p>
<blockquote>
<p>删除数据</p>
</blockquote>
<p>基本语法：</p>
<pre><code>delete from 表名 [where 条件];
</code></pre>
<p>例：</p>
<pre><code>-- 删除数据
delete from my_student where sex = 'male';
</code></pre>
<p><strong>注意：</strong> 删除不可逆，谨慎删除。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【转】160行代码仿Vue实现极简双向绑定]]></title>
        <id>https://duanjiuzhou.github.io/mengff.github.io/post/zhuan-160-xing-dai-ma-fang-vue-shi-xian-ji-jian-shuang-xiang-bang-ding/</id>
        <link href="https://duanjiuzhou.github.io/mengff.github.io/post/zhuan-160-xing-dai-ma-fang-vue-shi-xian-ji-jian-shuang-xiang-bang-ding/">
        </link>
        <updated>2020-08-04T08:26:17.000Z</updated>
        <summary type="html"><![CDATA[<p>精简vue双向绑定机制，对于没有好好研究过这方面知识的同学来说，当然是很难的，接下来本文用160行代码带你实现一个极简的双向绑定机制。</p>
]]></summary>
        <content type="html"><![CDATA[<p>精简vue双向绑定机制，对于没有好好研究过这方面知识的同学来说，当然是很难的，接下来本文用160行代码带你实现一个极简的双向绑定机制。</p>
<!-- more -->
<h2 id="前言">前言</h2>
<p>现在的前端面试不管你用的什么框架，总会问你这个框架的双向绑定机制，有的甚至要求你现场实现一个双向绑定出来，那对于没有好好研究过这方面知识的同学来说，当然是很难的，接下来本文用160行代码带你实现一个极简的双向绑定机制。</p>
<h2 id="效果gif">效果GIF：</h2>
<figure data-type="image" tabindex="1"><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642bc39f2604b1c?imageslim" alt="image" loading="lazy"></figure>
<h2 id="了解objectdefineproperty">了解Object.defineProperty()：</h2>
<p>这个API是实现双向绑定的核心，最主要的作用是重写数据的<code>get</code>、<code>set</code>方法。</p>
<h3 id="使用方式">使用方式：</h3>
<pre><code>    let obj = {
      singer: &quot;周杰伦&quot;
    };
    let value = &quot;青花瓷&quot;;
    Object.defineProperty(obj, &quot;music&quot;, {
      // value: '七里香', // 设置属性的值 下面设置了get set函数 所以这里不能设置
      configurable: false, // 是否可以删除属性 默认不能删除
      // writable: true,  // 是否可以修改对象 下面设置了get set函数 所以这里不能设置
      enumerable: true, // music是否可以被枚举 默认是不能被枚举(遍历)
      // ☆ get,set设置时不能设置writable和value，要一对一对设置，交叉设置/同时存在 就会报错
      get() {
        // 获取obj.music的时候就会调用get方法
        // let value = &quot;强行设置get的返回值&quot;; // 打开注释 读取属性永远都是‘强行设置get的返回值’
        return value;
      },
      set(val) {
        // 将修改的值重新赋给song
        value = val;
      }
    });
    console.log(obj.music); // 青花瓷
    delete obj.music; // configurable设为false 删除无效
    console.log(obj.music); // 青花瓷
    obj.music = &quot;听妈妈的话&quot;; 
    console.log(obj.music); // 听妈妈的话
    for (let key in obj) {
      // 默认情况下通过`defineProperty`定义的属性是不能被枚举(遍历)的
      // 需要设置enumerable为true才可以 否则只能拿到singer 属性
      console.log(key); // singer, music
    }
</code></pre>
<h3 id="画一下重点">画一下重点：</h3>
<ul>
<li>get,set设置时不能设置writable和value, 他们是一对情侣的存在，交叉设置或同时存在,会报错</li>
<li>通过defineProperty设置的属性，默认不能删除，不能遍历，当然你可以通过设置更改他们。</li>
<li>get、set 是函数，可以做的事情很多。</li>
</ul>
<p><strong>兼容性：</strong> IE 9,Firefox 4, Chorme 5,Opera 11.6,Safari 5.1</p>
<h2 id="实现思路">实现思路：</h2>
<h3 id="mvvm系列的双向绑定关键步骤">mvvm系列的双向绑定，关键步骤：</h3>
<ol>
<li>实现数据监听器Observer，用<code>Object.defineProperty()</code><strong>重写数据的get、set，值更新就在set中通知订阅者更新数据</strong>。</li>
<li>实现模板编译Compile，深度遍历dom树，对每个元素节点的指令模板进行<strong>替换数据以及订阅数据</strong>。</li>
<li>实现Watch用于连接Observer和Compile，<strong>能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图</strong>。</li>
<li>mvvm入口函数，整合以上三者。</li>
</ol>
<h3 id="流程图">流程图：</h3>
<figure data-type="image" tabindex="2"><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642bcf24d35456f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image" loading="lazy"></figure>
<h2 id="具体代码实现">具体代码实现：</h2>
<h3 id="html结构">html结构：</h3>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;
    &lt;h3 v-bind=&quot;name&quot;&gt;&lt;/h3&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;testData1&quot;&gt;
    &lt;h3&gt;{{ testData1 }}&lt;/h3&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;testData2&quot;&gt;
    &lt;h3&gt;{{ testData2 }}&lt;/h3&gt;
&lt;/div&gt;
</code></pre>
<h3 id="调用方法">调用方法：</h3>
<p>采用类Vue方式来使用双向绑定：</p>
<pre><code> window.onload = function () {
    var app = new myVue({
        el: '#app', // dom
        data: { // 数据
            testData1: '仿Vue',
            testData2: '极简双向绑定',
            name: 'OBKoro1'
        }
    })
}
</code></pre>
<h3 id="创建myvue函数">创建myVue函数：</h3>
<p>实际上这里是我们实现思路中的第四步，用于整合数据监听器<code>this._observer()</code>、指令解析器<code>this._compile()</code>以及连接Observer和Compile的_watcherTpl的watch池。</p>
<pre><code>    function myVue(options = {}) {  // 防止没传，设一个默认值
        this.$options = options; // 配置挂载
        this.$el = document.querySelector(options.el); // 获取dom
        this._data = options.data; // 数据挂载
        this._watcherTpl = {}; // watcher池
        this._observer(this._data); // 传入数据，执行函数，重写数据的get set
        this._compile(this.$el); // 传入dom，执行函数，编译模板 发布订阅
    };
</code></pre>
<h3 id="watcher函数">Watcher函数:</h3>
<p>这是实现思路中的第三步，因为下方数据监听器_observer()需要用到Watcher函数，所以这里就先讲了。</p>
<p>像实现思路中所说的，这里起到了连接Observer和Compile的作用：</p>
<ol>
<li><strong>在模板编译_compile()阶段发布订阅</strong></li>
<li><strong>在赋值操作的时候，更新视图</strong></li>
</ol>
<pre><code> // new Watcher() 为this._compile()发布订阅+ 在this._observer()中set(赋值)的时候更新视图
 function Watcher(el, vm, val, attr) {
     this.el = el; // 指令对应的DOM元素
     this.vm = vm; // myVue实例
     this.val = val; // 指令对应的值 
     this.attr = attr; // dom获取值，如value获取input的值 / innerHTML获取dom的值
     this.update(); // 更新视图
 }
 Watcher.prototype.update = function () { 
     this.el[this.attr] = this.vm._data[this.val]; // 获取data的最新值 赋值给dom 更新视图
 }
</code></pre>
<p>没有看错，代码量就这么多，可能需要把整个代码连接起来，多看几遍才能够理解。</p>
<h3 id="实现数据监听器_observer">实现数据监听器_observer()：</h3>
<p>实现思路中的第一步，用<code>Object.defineProperty()</code>遍历data重写所有属性的get set。</p>
<p>然后在给对象的某个属性赋值的时候，就会触发set。</p>
<p><strong>在set中我们可以监听到数据的变化，然后就可以触发watch更新视图。</strong></p>
<pre><code> myVue.prototype._observer = function (obj) {
        var _this = this;
        Object.keys(obj).forEach(key =&gt; { // 遍历数据
            _this._watcherTpl[key] = { // 每个数据的订阅池()
                _directives: []
            };
            var value = obj[key]; // 获取属性值
            var watcherTpl = _this._watcherTpl[key]; // 数据的订阅池
            Object.defineProperty(_this._data, key, { // 双向绑定最重要的部分 重写数据的set get
                configurable: true,  // 可以删除
                enumerable: true, // 可以遍历
                get() {
                    console.log(`${key}获取值：${value}`);
                    return value; // 获取值的时候 直接返回
                },
                set(newVal) { // 改变值的时候 触发set
                    console.log(`${key}更新：${newVal}`);
                    if (value !== newVal) {
                        value = newVal;
                        watcherTpl._directives.forEach((item) =&gt; { // 遍历订阅池 
                            item.update();
                            // 遍历所有订阅的地方(v-model+v-bind+{{}}) 触发this._compile()中发布的订阅Watcher 更新视图  
                        });
                    }
                }
            })
        });
    }
</code></pre>
<h3 id="实现compile-模板编译">实现Compile 模板编译</h3>
<p>这里是实现思路中的第三步，让我们来总结一下这里做了哪些事情：</p>
<ul>
<li>
<p>首先是深度遍历dom树，遍历每个节点以及子节点。</p>
</li>
<li>
<p>将模板中的变量替换成数据，初始化渲染页面视图。</p>
</li>
<li>
<p>把指令绑定的属性添加到对应的订阅池中</p>
</li>
<li>
<p>一旦数据有变动，收到通知，更新视图。</p>
</li>
</ul>
<pre><code>  myVue.prototype._compile = function (el) {
      var _this = this, nodes = el.children; // 获取app的dom
      for (var i = 0, len = nodes.length; i &lt; len; i++) { // 遍历dom节点
          var node = nodes[i];
          if (node.children.length) {
              _this._compile(node);  // 递归深度遍历 dom树
          }
          // 如果有v-model属性，并且元素是INPUT或者TEXTAREA，我们监听它的input事件    
          if (node.hasAttribute('v-model') &amp;&amp; (node.tagName = 'INPUT' || node.tagName == 'TEXTAREA')) {
              node.addEventListener('input', (function (key) {
                  var attVal = node.getAttribute('v-model'); // 获取v-model绑定的值
                  _this._watcherTpl[attVal]._directives.push(new Watcher( // 将dom替换成属性的数据并发布订阅 在set的时候更新数据
                      node,
                      _this,
                      attVal,
                      'value'
                  ));
                  return function () {
                      _this._data[attVal] = nodes[key].value;  // input值改变的时候 将新值赋给数据 触发set=&gt;set触发watch 更新视图
                  }
              })(i));
          }
          if (node.hasAttribute('v-bind')) { // v-bind指令 
              var attrVal = node.getAttribute('v-bind'); // 绑定的data
              _this._watcherTpl[attrVal]._directives.push(new Watcher( // 将dom替换成属性的数据并发布订阅 在set的时候更新数据
                  node,
                  _this,
                  attrVal,
                  'innerHTML'
              ))
          }
          var reg = /\{\{\s*([^}]+\S)\s*\}\}/g, txt = node.textContent;   // 正则匹配{{}}
          if (reg.test(txt)) {
              node.textContent = txt.replace(reg, (matched, placeholder) =&gt; {
                  // matched匹配的文本节点包括{{}}, placeholder 是{{}}中间的属性名
                  var getName = _this._watcherTpl; // 所有绑定watch的数据
                  getName = getName[placeholder];  // 获取对应watch 数据的值
                  if (!getName._directives) { // 没有事件池 创建事件池
                      getName._directives = [];
                  }
                  getName._directives.push(new Watcher( // 将dom替换成属性的数据并发布订阅 在set的时候更新数据
                      node,
                      _this,
                      placeholder,
                      'innerHTML'
                  ));
                  return placeholder.split('.').reduce((val, key) =&gt; {
                      return _this._data[key]; // 获取数据的值 触发get 返回当前值 
                  }, _this.$el);
              });
          }
      }
  }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【转】7分钟理解JS的节流、防抖及使用场景]]></title>
        <id>https://duanjiuzhou.github.io/mengff.github.io/post/zhuan-7-fen-zhong-li-jie-js-de-jie-liu-fang-dou-ji-shi-yong-chang-jing/</id>
        <link href="https://duanjiuzhou.github.io/mengff.github.io/post/zhuan-7-fen-zhong-li-jie-js-de-jie-liu-fang-dou-ji-shi-yong-chang-jing/">
        </link>
        <updated>2020-08-04T08:25:49.000Z</updated>
        <summary type="html"><![CDATA[<p>据说阿里有一道面试题就是谈谈函数节流和函数防抖。 糟了，这可触碰到我的知识盲区了，好像听也没听过这2个东西，痛定思痛，赶紧学习学习。</p>
]]></summary>
        <content type="html"><![CDATA[<p>据说阿里有一道面试题就是谈谈函数节流和函数防抖。 糟了，这可触碰到我的知识盲区了，好像听也没听过这2个东西，痛定思痛，赶紧学习学习。</p>
<!-- more -->
<h2 id="前言">前言</h2>
<p>据说阿里有一道面试题就是谈谈函数节流和函数防抖。 糟了，这可触碰到我的知识盲区了，好像听也没听过这2个东西，痛定思痛，赶紧学习学习。here we go！</p>
<h2 id="概念和例子">概念和例子</h2>
<h4 id="函数防抖debounce">函数防抖(debounce)</h4>
<blockquote>
<p>在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</p>
</blockquote>
<p>看一个（栗子）：</p>
<pre><code>//模拟一段ajax请求
function ajax(content) {
  console.log('ajax request ' + content)
}

let inputa = document.getElementById('unDebounce')

inputa.addEventListener('keyup', function (e) {
    ajax(e.target.value)
})
</code></pre>
<p>看一下运行结果：</p>
<figure data-type="image" tabindex="1"><img src="https://user-gold-cdn.xitu.io/2018/9/4/165a252be5c94d6b?imageslim" alt="image" loading="lazy"></figure>
<p>可以看到，我们只要按下键盘，就会触发这次ajax请求。不仅从资源上来说是很浪费的行为，而且实际应用中，用户也是输出完整的字符后，才会请求。下面我们优化一下：</p>
<pre><code>//模拟一段ajax请求
function ajax(content) {
  console.log('ajax request ' + content)
}

function debounce(fun, delay) {
    return function (args) {
        let that = this
        let _args = args
        clearTimeout(fun.id)
        fun.id = setTimeout(function () {
            fun.call(that, _args)
        }, delay)
    }
}
    
let inputb = document.getElementById('debounce')

let debounceAjax = debounce(ajax, 500)

inputb.addEventListener('keyup', function (e) {
        debounceAjax(e.target.value)
    })
</code></pre>
<p>看一下运行结果：</p>
<figure data-type="image" tabindex="2"><img src="https://user-gold-cdn.xitu.io/2018/9/4/165a252b4b429b56?imageslim" alt="image" loading="lazy"></figure>
<p>可以看到，我们加入了防抖以后，当你在频繁的输入时，并不会发送请求，只有当你在指定间隔内没有输入时，才会执行函数。如果停止输入但是在指定间隔内又输入，会重新触发计时。 再看一个例子：</p>
<pre><code>let biu = function () {
    console.log('biu biu biu',new Date().Format('HH:mm:ss'))
}

let boom = function () {
    console.log('boom boom boom',new Date().Format('HH:mm:ss'))
}


setInterval(debounce(biu,500),1000)
setInterval(debounce(boom,2000),1000)
</code></pre>
<p>看一下运行结果：</p>
<figure data-type="image" tabindex="3"><img src="https://user-gold-cdn.xitu.io/2018/9/4/165a252b4b809a23?imageslim" alt="image" loading="lazy"></figure>
<p>这个例子就很好的解释了，如果在时间间隔内执行函数，会重新触发计时。biu会在第一次1.5s执行后，每隔1s执行一次，而boom一次也不会执行。因为它的时间间隔是2s，而执行时间是1s，所以每次都会重新触发计时</p>
<blockquote>
<p>个人理解 函数防抖就是法师发技能的时候要读条，技能读条没完再按技能就会重新读条。</p>
</blockquote>
<h4 id="函数节流throttle">函数节流(throttle)</h4>
<blockquote>
<p>规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。</p>
</blockquote>
<p>看一个例子：</p>
<pre><code>function throttle(fun, delay) {
        let last, deferTimer
        return function (args) {
            let that = this
            let _args = arguments
            let now = +new Date()
            if (last &amp;&amp; now &lt; last + delay) {
                clearTimeout(deferTimer)
                deferTimer = setTimeout(function () {
                    last = now
                    fun.apply(that, _args)
                }, delay)
            }else {
                last = now
                fun.apply(that,_args)
            }
        }
    }

    let throttleAjax = throttle(ajax, 1000)

    let inputc = document.getElementById('throttle')
    inputc.addEventListener('keyup', function(e) {
        throttleAjax(e.target.value)
    })
</code></pre>
<p>看一下运行结果：</p>
<figure data-type="image" tabindex="4"><img src="https://user-gold-cdn.xitu.io/2018/9/4/165a252b4c1a9686?imageslim" alt="image" loading="lazy"></figure>
<p>可以看到，我们在不断输入时，ajax会按照我们设定的时间，每1s执行一次。</p>
<p>结合刚刚biubiubiu的例子：</p>
<pre><code>    let biubiu = function () {
        console.log('biu biu biu', new Date().Format('HH:mm:ss'))
    }

    setInterval(throttle(biubiu,1000),10)
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://user-gold-cdn.xitu.io/2018/9/4/165a252b46818296?imageslim" alt="image" loading="lazy"></figure>
<p>不管我们设定的执行时间间隔多小，总是1s内只执行一次。</p>
<blockquote>
<p>个人理解 函数节流就是fps游戏的射速，就算一直按着鼠标射击，也只会在规定射速内射出子弹。</p>
</blockquote>
<h2 id="总结">总结</h2>
<ul>
<li>函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的原理却不一样。</li>
<li>函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。</li>
</ul>
<h4 id="结合应用场景">结合应用场景</h4>
<ol>
<li>
<p>ebounce</p>
<ul>
<li>search搜索联想，用户在不断输入值时，用防抖来节约请求资源。<br>
*window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次</li>
</ul>
</li>
<li>
<p>throttle</p>
<ul>
<li>鼠标不断点击触发，mousedown(单位时间内只触发一次)</li>
<li>监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断</li>
</ul>
</li>
</ol>
<p><em>转载：作者：薄荷前端<br>
<a href="https://juejin.im/post/5b8de829f265da43623c4261">链接</a></em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mysql操作 (二) 之SQL 表操作（字段）]]></title>
        <id>https://duanjiuzhou.github.io/mengff.github.io/post/mysql-cao-zuo-er-zhi-sql-biao-cao-zuo-zi-duan/</id>
        <link href="https://duanjiuzhou.github.io/mengff.github.io/post/mysql-cao-zuo-er-zhi-sql-biao-cao-zuo-zi-duan/">
        </link>
        <updated>2020-08-04T08:25:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="sql-表操作字段">SQL 表操作（字段）</h2>
<blockquote>
<p>新增数据表</p>
</blockquote>
<p>基本语法:</p>
<pre><code>create table [if not exists] 表名(
字段名字 数据类型,
字段名字 数据类型       -- 最后一行不需要逗号
)[表选项];
</code></pre>
<p><strong>解释：</strong></p>
<p>if not exists：如果表名不存在，那么创建，否则不执行创建代码（检查功能）</p>
<p>表选项：控制表的表现</p>
<p>字符集：charset/charset set 具体字符集;  -- 保证表中数据存储的字符集</p>
<p>校对集：collate 具体校对集；</p>
<p>存储引擎：engine 具体的存储引擎（innodb 和 myisam）</p>
<p>任何一个表的设计都必须指定数据库。</p>
<ol>
<li>
<p>方案1：:显示的指定表所属的数据库</p>
<pre><code>create tabe 数据库名.表名();  -- 将当期数据表创建到指定的数据库中
</code></pre>
<p>例：</p>
<pre><code> -- 创建数据表
 create table if not exists mydatabase.student(  -- 显示的student表放到mydatabase数据库下
    name varchar(10),
    gender varchar(12),
    number int
    age int
 )charset utf8;
</code></pre>
</li>
<li>
<p>方案2：隐式的指定表所属数据库：先进入到某个数据库环境，然后这样创建的表自动归属到某个指定的数据库。</p>
<p>进入数据库环境：use 数据库名字;</p>
<p>例：</p>
<pre><code>-- 创建数据表
-- 进入数据库
use mydatabase;

-- 创建表
create table class(
name varchar(10),
room varchar(10)
)charset utf8;
</code></pre>
<p>当创建数据表的SQL指令执行之后，发生了什么？</p>
<ul>
<li>指定数据库下已存在对应的表</li>
<li>在数据库对应的文件夹下，会产生对应表的数据结构文件（跟存储引擎有关系）</li>
</ul>
</li>
</ol>
<blockquote>
<p>查看数据表</p>
</blockquote>
<ol>
<li>
<p>查看所有表</p>
<p>基本语法：</p>
<pre><code>show tables;
</code></pre>
</li>
<li>
<p>查看部分表：模糊匹配</p>
<p>基本语法：</p>
<pre><code>show tables like 'pattern';
</code></pre>
<p>例：</p>
<pre><code>--查看以s结尾的表
show table like '%s';
</code></pre>
</li>
<li>
<p>查看表创建语句</p>
<p>基本语法：</p>
<pre><code>show create table 表名;
</code></pre>
<p>例：</p>
<pre><code>--  查看表创建语句
show create table student\g  -- \g 等同于 ;
show create table student\G  -- 将查到的结构旋转90度变成纵向。
</code></pre>
</li>
<li>
<p>查看表结构：查看表中的字段信息</p>
</li>
</ol>
<p>基本语法：</p>
<pre><code>~~~
desc/describe/show columns from 表名;
~~~

例：

~~~
-- 查看表结构
desc calss;
describe calss;
show columns from class;  // 以上三种语法表达的意思都一样
~~~
</code></pre>
<blockquote>
<p>修改数据表</p>
</blockquote>
<p>表本身存在，还包含字段：表的修改包含两部分：修改表本身和修改字段。</p>
<ol>
<li>修改表本身</li>
</ol>
<p>表本身可以修改：表名和表选项</p>
<ul>
<li>
<p>修改表名：</p>
<pre><code>rename table 老表名 to 新表名;
</code></pre>
</li>
<li>
<p>修改表选项：字符集、校对集和存储引擎</p>
<pre><code>alter table 表名 表选项 [=] 值;
</code></pre>
<p>例：</p>
<pre><code>-- 修改表选项：字符集
alter table my_student clarset = GBK;
</code></pre>
</li>
</ul>
<ol start="2">
<li>修改字段</li>
</ol>
<p>字段操作很多：新增，修改，重名，删除</p>
<ul>
<li>
<p>新增字段：</p>
<pre><code>alter table 表名 add [column] 字段名 数据类型 [列属性][位置];

位置：字段名可以存放表中任意位置
    first：第一个位置
    after：在哪个字段之后：after字段名；默认的是在最后一个字段之后。
</code></pre>
<p>例：</p>
<pre><code>-- 给学生表增加ID放在第一个位置
alter table my_student add column id int first;
</code></pre>
</li>
<li>
<p>修改字段：修改通常是修改属性或者数据类型</p>
<pre><code>alter table 表名 modify 字段名 数据类型 [属性][位置];
</code></pre>
<p>例：</p>
<pre><code>-- 将学生表中的number学号字段变成固定长度，且放到第二位（id之后）
alter table my_student modify number char(10) after id;
</code></pre>
</li>
<li>
<p>重命名字段</p>
<pre><code>alter table 表名 change 旧字段 新字段 数据类型 [属性][位置];
</code></pre>
<p>例：</p>
<pre><code>-- 修改学生表中的 gender字段为sex
alter table my_student change gender sex varchar(10);
</code></pre>
</li>
<li>
<p>删除字段</p>
<pre><code>alter table 表名 drop 字段名;
</code></pre>
</li>
</ul>
<p><strong>小心：</strong>  如果表中已经存在数据，那么删除字段会清空该字段的所有数据（不可逆）</p>
<blockquote>
<p>删除数据表</p>
</blockquote>
<p>基本语法：</p>
<pre><code>drop table 表名1,表名2;  --可以一次性删除多张表
</code></pre>
<p>当删除数据表的指令执行后发生了什么？</p>
<ul>
<li>在表空间中，没有了指定的表（数据也没有了）</li>
<li>在数据库对应的文件夹下，表对应的文件（与存储引擎有关）也删除了。</li>
</ul>
<p>注意：删除有危险操作需谨慎（不可逆）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mysql操作 (一) 之基本指令、SQL 库操作]]></title>
        <id>https://duanjiuzhou.github.io/mengff.github.io/post/mysql-cao-zuo-yi-zhi-ji-ben-zhi-ling-sql-ku-cao-zuo/</id>
        <link href="https://duanjiuzhou.github.io/mengff.github.io/post/mysql-cao-zuo-yi-zhi-ji-ben-zhi-ling-sql-ku-cao-zuo/">
        </link>
        <updated>2020-08-04T08:24:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-基本指令">1、基本指令</h2>
<pre><code>mysql -u root -p  --连接数据库
use &lt;数据库名&gt;    --使用数据库
show databases    --查询所有数据库 注：use 数据库后才能操作
exit/quilt/\q     --断开连接 三种方式
</code></pre>
<p><strong>注意：</strong></p>
<p>数据库名字以字母数字下划线组成，不能以数字开头。</p>
<p>-- 双中划线+空格：注释（单行注释），也可以使用#号</p>
<h2 id="2-sql-库操作">2、SQL 库操作</h2>
<blockquote>
<p>新增数据库</p>
</blockquote>
<p>基本语法</p>
<pre><code>create database 数据库名字 [库选项];

例：
create database myDatabase charset utf8;
</code></pre>
<p><strong>库选项：</strong></p>
<p>用来约束数据库，分为两个选项：</p>
<p>字符集设定：charset/character set 具体字符集（数据存储的编码格式）：常用字符集 GBK和UTF8</p>
<p>校对集设定：collate具体校对集（数据比较的规则）</p>
<p><strong>注意：</strong></p>
<ol>
<li>
<p>数据库名字不能使用关键字（已经被使用的字符）或者保留字（将来可能用到的）</p>
<pre><code>-- 创建关键字数据库 会报错
create database database charset utf8;
</code></pre>
<p>如果非要使用关键字或者保留字，那么必须使用反引号``。</p>
<pre><code>-- 使用反引号 包裹关键字
create database `database` charset utf8;
</code></pre>
</li>
<li>
<p>中文数据库是可以的，但是有个前提条件：保证服务器能够识别。（建议不用）</p>
<pre><code>-- 创建中文数据库
create database `中国` charset utf8;  // 报错
create database 中国 charset utf8;    // 报错
</code></pre>
<p>解决方案：</p>
<p>告诉服务器当前中文的字符集是什么</p>
<pre><code>set names gbk;
create database 中国 charset utf8;
</code></pre>
</li>
<li>
<p>当创建数据库的SQL语句执行以后，发生了什么？</p>
<ul>
<li>在数据库系统中，增加了对应的数据库信息</li>
<li>会在保存数据的文件夹下，data目录，创建一个对应数据库名字的文件夹</li>
<li>每个数据库下都有一个opt文件</li>
</ul>
</li>
</ol>
<blockquote>
<p>查看数据库</p>
</blockquote>
<ol>
<li>
<p>查看所有数据库</p>
<pre><code>show databases;
</code></pre>
</li>
<li>
<p>查看指定部分的数据库：模糊查询</p>
<pre><code>show databases like 'pattern';    --pattern 是匹配模式
%：表示匹配多个字符
_：表示匹配单个字符
</code></pre>
<p>例：</p>
<pre><code>-- 查看以inform_开始的数据库：_需要被转义
show database like 'inform\_%';

show database like 'inform_%';  -- 相当于inform%
</code></pre>
</li>
<li>
<p>查看数据库的创建语句</p>
<pre><code>show create database 数据库名字;
</code></pre>
</li>
</ol>
<blockquote>
<p>更新数据库</p>
</blockquote>
<p>数据库名字不可以修改。</p>
<p>数据库的修改仅限于库选项：字符集和校对集（校对集依赖于字符集）</p>
<p>基本格式：</p>
<pre><code>alter database 数据库名字 [库选项];
charset/charset set[=] 字符集
collate 校对集
</code></pre>
<p>例：</p>
<pre><code>-- 修改数据库inform的字符集
alter database inform chartset GBK;
</code></pre>
<blockquote>
<p>删除数据库</p>
</blockquote>
<p>基本格式：</p>
<pre><code>drop database 数据库名字;
</code></pre>
<p>当删除数据库语句执行之后发生什么？</p>
<ul>
<li>在数据库内部看不到对应的数据库；</li>
<li>在对应的数据库存储的文件夹中：数据库名字对应的文件夹也被删除（级联删除：里面的数据表全部删除）</li>
</ul>
<p><strong>注意：</strong></p>
<p>数据库不要随意删除，应该先进行备份后操作。（删除不可逆）</p>
]]></content>
    </entry>
</feed>